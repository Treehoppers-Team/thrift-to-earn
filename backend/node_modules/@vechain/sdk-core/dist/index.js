"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Account: () => Account,
  Address: () => Address,
  BLOCK_REF_LENGTH: () => BLOCK_REF_LENGTH,
  Blake2b256: () => Blake2b256,
  BloomFilter: () => BloomFilter,
  ERC1155_ABI: () => ERC1155_ABI,
  ERC20_ABI: () => ERC20_ABI,
  ERC721_ABI: () => ERC721_ABI,
  FPN: () => FPN,
  HDKey: () => HDKey2,
  Hex: () => Hex,
  HexInt: () => HexInt,
  HexUInt: () => HexUInt,
  Keccak256: () => Keccak256,
  MAINNET_NETWORK: () => MAINNET_NETWORK,
  Mnemonic: () => Mnemonic,
  NUMERIC_REGEX: () => NUMERIC_REGEX,
  Quantity: () => Quantity,
  RLPBase: () => RLPBase,
  RLPProfiles: () => RLPProfiles,
  RLP_CODER: () => RLP_CODER,
  Revision: () => Revision,
  SIGNATURE_LENGTH: () => SIGNATURE_LENGTH,
  SIGNED_TRANSACTION_RLP: () => SIGNED_TRANSACTION_RLP,
  SOLO_NETWORK: () => SOLO_NETWORK,
  Secp256k1: () => Secp256k1,
  Sha256: () => Sha256,
  TESTNET_NETWORK: () => TESTNET_NETWORK,
  TRANSACTIONS_GAS_CONSTANTS: () => TRANSACTIONS_GAS_CONSTANTS,
  TRANSACTION_FEATURES_KIND: () => TRANSACTION_FEATURES_KIND,
  TRANSACTION_SIGNATURE_KIND: () => TRANSACTION_SIGNATURE_KIND,
  ThorId: () => ThorId,
  Transaction: () => Transaction,
  TransactionHandler: () => TransactionHandler,
  TransactionUtils: () => TransactionUtils,
  Txt: () => Txt,
  UNSIGNED_TRANSACTION_RLP: () => UNSIGNED_TRANSACTION_RLP,
  VIP180_ABI: () => VIP180_ABI,
  VIP181_ABI: () => VIP181_ABI,
  VIP210_ABI: () => VIP210_ABI,
  VTHO_ADDRESS: () => VTHO_ADDRESS,
  ZERO_ADDRESS: () => ZERO_ADDRESS,
  ZERO_BYTES: () => ZERO_BYTES,
  abi: () => abi,
  addressUtils: () => addressUtils,
  assertCompactFixedHexBlobBuffer: () => assertCompactFixedHexBlobBuffer,
  assertFixedHexBlobKindBuffer: () => assertFixedHexBlobKindBuffer,
  assertFixedHexBlobKindData: () => assertFixedHexBlobKindData,
  assertValidHexBlobKindBuffer: () => assertValidHexBlobKindBuffer,
  assertValidHexBlobKindData: () => assertValidHexBlobKindData,
  assertValidNumericKindBuffer: () => assertValidNumericKindBuffer,
  blake2b256: () => blake2b256,
  certificate: () => certificate,
  clauseBuilder: () => clauseBuilder,
  coder: () => coder,
  core: () => core_exports,
  dataUtils: () => dataUtils,
  decodeBufferToHexWithLeadingZeros: () => decodeBufferToHexWithLeadingZeros,
  decodeBufferToNumberOrHex: () => decodeBufferToNumberOrHex,
  encodeBigIntToBuffer: () => encodeBigIntToBuffer,
  encodeCompactFixedHexBlob: () => encodeCompactFixedHexBlob,
  fragment: () => fragment,
  keccak256: () => keccak256,
  keystore: () => keystore3,
  mnemonic: () => mnemonic,
  networkInfo: () => networkInfo,
  revisionUtils: () => revisionUtils,
  sha256: () => sha2562,
  unitsUtils: () => unitsUtils,
  validateNumericKindData: () => validateNumericKindData,
  vechain_sdk_core_ethers: () => import_ethers6.ethers
});
module.exports = __toCommonJS(src_exports);

// src/core.ts
var core_exports = {};
__export(core_exports, {
  Account: () => Account,
  Address: () => Address,
  BLOCK_REF_LENGTH: () => BLOCK_REF_LENGTH,
  Blake2b256: () => Blake2b256,
  BloomFilter: () => BloomFilter,
  ERC1155_ABI: () => ERC1155_ABI,
  ERC20_ABI: () => ERC20_ABI,
  ERC721_ABI: () => ERC721_ABI,
  FPN: () => FPN,
  HDKey: () => HDKey2,
  Hex: () => Hex,
  HexInt: () => HexInt,
  HexUInt: () => HexUInt,
  Keccak256: () => Keccak256,
  MAINNET_NETWORK: () => MAINNET_NETWORK,
  Mnemonic: () => Mnemonic,
  NUMERIC_REGEX: () => NUMERIC_REGEX,
  Quantity: () => Quantity,
  RLPBase: () => RLPBase,
  RLPProfiles: () => RLPProfiles,
  RLP_CODER: () => RLP_CODER,
  Revision: () => Revision,
  SIGNATURE_LENGTH: () => SIGNATURE_LENGTH,
  SIGNED_TRANSACTION_RLP: () => SIGNED_TRANSACTION_RLP,
  SOLO_NETWORK: () => SOLO_NETWORK,
  Secp256k1: () => Secp256k1,
  Sha256: () => Sha256,
  TESTNET_NETWORK: () => TESTNET_NETWORK,
  TRANSACTIONS_GAS_CONSTANTS: () => TRANSACTIONS_GAS_CONSTANTS,
  TRANSACTION_FEATURES_KIND: () => TRANSACTION_FEATURES_KIND,
  TRANSACTION_SIGNATURE_KIND: () => TRANSACTION_SIGNATURE_KIND,
  ThorId: () => ThorId,
  Transaction: () => Transaction,
  TransactionHandler: () => TransactionHandler,
  TransactionUtils: () => TransactionUtils,
  Txt: () => Txt,
  UNSIGNED_TRANSACTION_RLP: () => UNSIGNED_TRANSACTION_RLP,
  VIP180_ABI: () => VIP180_ABI,
  VIP181_ABI: () => VIP181_ABI,
  VIP210_ABI: () => VIP210_ABI,
  VTHO_ADDRESS: () => VTHO_ADDRESS,
  ZERO_ADDRESS: () => ZERO_ADDRESS,
  ZERO_BYTES: () => ZERO_BYTES,
  abi: () => abi,
  addressUtils: () => addressUtils,
  assertCompactFixedHexBlobBuffer: () => assertCompactFixedHexBlobBuffer,
  assertFixedHexBlobKindBuffer: () => assertFixedHexBlobKindBuffer,
  assertFixedHexBlobKindData: () => assertFixedHexBlobKindData,
  assertValidHexBlobKindBuffer: () => assertValidHexBlobKindBuffer,
  assertValidHexBlobKindData: () => assertValidHexBlobKindData,
  assertValidNumericKindBuffer: () => assertValidNumericKindBuffer,
  blake2b256: () => blake2b256,
  certificate: () => certificate,
  clauseBuilder: () => clauseBuilder,
  coder: () => coder,
  dataUtils: () => dataUtils,
  decodeBufferToHexWithLeadingZeros: () => decodeBufferToHexWithLeadingZeros,
  decodeBufferToNumberOrHex: () => decodeBufferToNumberOrHex,
  encodeBigIntToBuffer: () => encodeBigIntToBuffer,
  encodeCompactFixedHexBlob: () => encodeCompactFixedHexBlob,
  fragment: () => fragment,
  keccak256: () => keccak256,
  keystore: () => keystore3,
  mnemonic: () => mnemonic,
  networkInfo: () => networkInfo,
  revisionUtils: () => revisionUtils,
  sha256: () => sha2562,
  unitsUtils: () => unitsUtils,
  validateNumericKindData: () => validateNumericKindData,
  vechain_sdk_core_ethers: () => import_ethers6.ethers
});
var import_ethers6 = require("ethers");

// src/abi/fragment.ts
var import_ethers = require("ethers");
var import_sdk_errors = require("@vechain/sdk-errors");

// src/abi/helpers/fragment.ts
var sanitizeValuesToEncode = (valuesToEncode, event) => {
  if (valuesToEncode.length === 0) return [];
  if (valuesToEncode.length > event.inputs.length) return valuesToEncode;
  const sanitizedValuesToEncode = [];
  const eventInputs = event.inputs;
  for (const input of eventInputs) {
    if (input.indexed === true && valuesToEncode.length > 0 && valuesToEncode[0] !== void 0) {
      sanitizedValuesToEncode.push(valuesToEncode.shift());
    } else {
      if (valuesToEncode.length > 0 && valuesToEncode[0] === void 0) {
        valuesToEncode.shift();
      }
      sanitizedValuesToEncode.push(null);
    }
  }
  return sanitizedValuesToEncode;
};

// src/abi/fragment.ts
var allowedSignatureFormats = ["sighash", "minimal", "full", "json"];
function getSignature(fragment2, formatType) {
  if (!allowedSignatureFormats.includes(formatType)) {
    throw new import_sdk_errors.InvalidAbiSignatureFormat(
      "getSignature()",
      "Initialization failed: Cannot create Function fragment. Function format is invalid.",
      {
        signatureFormat: formatType
      }
    );
  }
  return fragment2.format(formatType);
}
var Function = class {
  /**
   * The main fragment handled by ethers.js.
   *
   */
  fragment;
  /**
   * The main interface handled by ethers.js.
   */
  iface;
  /**
   * Creates a new Function instance from an ABI fragment.
   *
   * @param source - ABI fragment to use.
   * @throws {InvalidAbiFragment}
   */
  constructor(source) {
    try {
      this.fragment = import_ethers.ethers.FunctionFragment.from(source);
      this.iface = new import_ethers.ethers.Interface([this.fragment]);
    } catch (e) {
      throw new import_sdk_errors.InvalidAbiFragment(
        "abi.Function constructor",
        "Initialization failed: Cannot create Function fragment. Function format is invalid.",
        {
          type: "function",
          fragment: source
        },
        e
      );
    }
  }
  /**
   * Get the signature hash of the function.
   *
   * @returns The signature hash of the function.
   */
  signatureHash() {
    return this.fragment.selector;
  }
  /**
   * Get the signature of the function.
   *
   * @param formatType - The format type of the signature: 'sighash', 'minimal', 'full', or 'json'.
   * @returns The signature of the function.
   */
  signature(formatType) {
    return getSignature(this.fragment, formatType);
  }
  /**
   * Decode data using the function's ABI.
   *
   * @param data - Data to decode.
   * @returns Decoding results.
   * @throws {InvalidAbiDataToEncodeOrDecode}
   */
  decodeInput(data) {
    try {
      return this.iface.decodeFunctionData(this.fragment, data);
    } catch (e) {
      throw new import_sdk_errors.InvalidAbiDataToEncodeOrDecode(
        "abi.Function.decodeInput()",
        "Decoding failed: Data must be a valid hex string encoding a compliant ABI type.",
        { data },
        e
      );
    }
  }
  /**
   * Decodes the output data from a transaction based on ABI (Application Binary Interface) specifications.
   * This method attempts to decode the given byte-like data into a readable format using the contract's interface.
   *
   * @param data - The `BytesLike` data to be decoded, typically representing the output of a contract function call.
   * @returns A `Result` object containing the decoded data.
   * @throws {InvalidAbiDataToEncodeOrDecode}
   *
   * @example
   * ```typescript
   *   const decoded = contractInstance.decodeOutput(rawTransactionOutput);
   *   console.log('Decoded Output:', decoded);
   * ```
   */
  decodeOutput(data) {
    try {
      return this.iface.decodeFunctionResult(this.fragment, data);
    } catch (e) {
      throw new import_sdk_errors.InvalidAbiDataToEncodeOrDecode(
        "abi.Function.decodeOutput()",
        "Decoding failed: Data must be a valid hex string encoding a compliant ABI type.",
        { data },
        e
      );
    }
  }
  /**
   * Encode data using the function's ABI.
   *
   * @param dataToEncode - Data to encode.
   * @returns Encoded data.
   * @throws {InvalidAbiDataToEncodeOrDecode}
   */
  encodeInput(dataToEncode) {
    try {
      return this.iface.encodeFunctionData(this.fragment, dataToEncode);
    } catch (e) {
      throw new import_sdk_errors.InvalidAbiDataToEncodeOrDecode(
        "abi.Function.encodeInput()",
        "Encoding failed: Data format is invalid. Function data does not match the expected format for ABI type encoding.",
        { dataToEncode },
        e
      );
    }
  }
};
var Event = class {
  /**
   * The main fragment handled by ethers.js.
   */
  fragment;
  /**
   * The main interface handled by ethers.js.
   */
  iface;
  /**
   * Creates a new Event instance from an ABI fragment.
   *
   * @param source - ABI fragment to use.
   * @throws {InvalidAbiFragment}
   */
  constructor(source) {
    try {
      this.fragment = import_ethers.ethers.EventFragment.from(source);
      this.iface = new import_ethers.ethers.Interface([this.fragment]);
    } catch (e) {
      throw new import_sdk_errors.InvalidAbiFragment(
        "abi.Event constructor",
        "Initialization failed: Cannot create Event fragment. Event format is invalid.",
        {
          type: "event",
          fragment: source
        },
        e
      );
    }
  }
  /**
   * Get the signature hash of the event.
   *
   * @returns The signature hash of the event.
   */
  signatureHash() {
    return this.fragment.topicHash;
  }
  /**
   * Get the signature of the event.
   *
   * @param formatType - The format type of the signature: 'sighash', 'minimal', 'full', or 'json'.
   * @returns The signature of the event.
   */
  signature(formatType) {
    return getSignature(this.fragment, formatType);
  }
  /**
   * Decode event log data using the event's ABI.
   *
   * @param data - Data to decode.
   * @returns Decoding results.
   * @throws {InvalidAbiDataToEncodeOrDecode}
   */
  decodeEventLog(data) {
    try {
      return this.iface.decodeEventLog(
        this.fragment,
        data.data,
        data.topics
      );
    } catch (e) {
      throw new import_sdk_errors.InvalidAbiDataToEncodeOrDecode(
        "abi.Event.decodeEventLog()",
        "Decoding failed: Data must be a valid hex string encoding a compliant ABI type.",
        { data },
        e
      );
    }
  }
  /**
   * Encode event log data using the event's ABI.
   *
   * @param dataToEncode - Data to encode.
   * @returns Encoded data along with topics.
   * @throws {InvalidAbiDataToEncodeOrDecode}
   */
  encodeEventLog(dataToEncode) {
    try {
      return this.iface.encodeEventLog(this.fragment, dataToEncode);
    } catch (e) {
      throw new import_sdk_errors.InvalidAbiDataToEncodeOrDecode(
        "abi.Event.encodeEventLog()",
        "Encoding failed: Data format is invalid. Event data does not match the expected format for ABI type encoding.",
        { dataToEncode },
        e
      );
    }
  }
  /**
   * Encode event log topics using the event's ABI.
   *
   * @param valuesToEncode - values to encode as topics. Non-indexed values are ignored.
   *                         Only the values of the indexed parameters are needed.
   * @returns Encoded topics array.
   * @throws {InvalidAbiDataToEncodeOrDecode}
   */
  encodeFilterTopics(valuesToEncode) {
    try {
      const sanitizedValuesToEncode = sanitizeValuesToEncode(
        valuesToEncode,
        this.fragment
      );
      return this.iface.encodeFilterTopics(this.fragment, sanitizedValuesToEncode).map((topic) => topic ?? void 0);
    } catch (e) {
      throw new import_sdk_errors.InvalidAbiDataToEncodeOrDecode(
        "abi.Event.encodeEventLog()",
        "Encoding failed: Data format is invalid. Event topics values must be correctly formatted for ABI-compliant encoding.",
        { valuesToEncode },
        e
      );
    }
  }
};
var fragment = {
  Function,
  Event
};

// src/abi/coder.ts
var import_ethers2 = require("ethers");
var import_sdk_errors2 = require("@vechain/sdk-errors");
var ethersCoder = new import_ethers2.ethers.AbiCoder();
function encode(type, value) {
  try {
    return ethersCoder.encode([type], [value]);
  } catch (e) {
    throw new import_sdk_errors2.InvalidAbiDataToEncodeOrDecode(
      "abi.encode()",
      "Encoding failed: Data must be a valid ABI type with corresponding valid data.",
      {
        type,
        value
      },
      e
    );
  }
}
function encodeParams(types, values) {
  try {
    return ethersCoder.encode(types, values);
  } catch (e) {
    throw new import_sdk_errors2.InvalidAbiDataToEncodeOrDecode(
      "abi.encodeParams()",
      "Encoding failed: Data must be a valid ABI type with corresponding valid data.",
      {
        types,
        values
      },
      e
    );
  }
}
function decode(types, data) {
  try {
    const decoded = ethersCoder.decode([types], data).toArray();
    return decoded[0];
  } catch (e) {
    throw new import_sdk_errors2.InvalidAbiDataToEncodeOrDecode(
      "abi.decode()",
      "Decoding failed: Data must be a valid ABI type with corresponding valid data.",
      {
        types,
        data
      },
      e
    );
  }
}
var abi = {
  ...fragment,
  encode,
  encodeParams,
  decode
};

// src/contract/coder.ts
var import_ethers3 = require("ethers");
var import_sdk_errors3 = require("@vechain/sdk-errors");
function createInterface(abi2) {
  return new import_ethers3.Interface(abi2);
}
function encodeFunctionInput(interfaceABI, functionName, functionData) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return new abi.Function(
      contractInterface.getFunction(functionName)
    ).encodeInput(functionData);
  } catch (e) {
    throw new import_sdk_errors3.InvalidAbiDataToEncodeOrDecode(
      "coder.encodeFunctionInput()",
      `Encoding failed: Data format is invalid. Function data does not match the expected format for ABI type encoding.`,
      { interfaceABI, functionName, functionData },
      e
    );
  }
}
function decodeFunctionInput(interfaceABI, functionName, encodedFunctionInput) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return new abi.Function(
      contractInterface.getFunction(functionName)
    ).decodeInput(encodedFunctionInput);
  } catch (e) {
    throw new import_sdk_errors3.InvalidAbiDataToEncodeOrDecode(
      "coder.decodeFunctionInput()",
      "Decoding failed: Data must be a valid hex string encoding a compliant ABI type.",
      { interfaceABI, functionName, encodedFunctionInput },
      e
    );
  }
}
function decodeFunctionOutput(interfaceABI, functionName, encodedFunctionOutput) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return new abi.Function(
      contractInterface.getFunction(functionName)
    ).decodeOutput(encodedFunctionOutput);
  } catch (e) {
    throw new import_sdk_errors3.InvalidAbiDataToEncodeOrDecode(
      "coder.decodeFunctionOutput()",
      `Decoding failed: Data must be a valid hex string encoding a compliant ABI type.`,
      { interfaceABI, functionName, encodedFunctionOutput },
      e
    );
  }
}
function encodeEventLog(interfaceABI, eventName, dataToEncode) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return new abi.Event(
      contractInterface.getEvent(eventName)
    ).encodeEventLog(dataToEncode);
  } catch (e) {
    throw new import_sdk_errors3.InvalidAbiDataToEncodeOrDecode(
      "coder.encodeEventLog()",
      `Encoding failed: Data format is invalid. Event data does not match the expected format for ABI type encoding.`,
      { interfaceABI, eventName, dataToEncode },
      e
    );
  }
}
function decodeEventLog(interfaceABI, eventName, dataToDecode) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return new abi.Event(
      contractInterface.getEvent(eventName)
    ).decodeEventLog(dataToDecode);
  } catch (e) {
    throw new import_sdk_errors3.InvalidAbiDataToEncodeOrDecode(
      "coder.decodeEventLog()",
      `Decoding failed: Data must be a valid hex string encoding a compliant ABI type.`,
      { interfaceABI, eventName, dataToDecode },
      e
    );
  }
}
function parseLog(interfaceABI, data, topics) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return contractInterface.parseLog({ topics, data });
  } catch (e) {
    throw new import_sdk_errors3.InvalidAbiDataToEncodeOrDecode(
      "coder.parseLog()",
      `Decoding failed: Data must be a valid hex string encoding a compliant ABI type.`,
      { interfaceABI, data, topics },
      e
    );
  }
}
var coder = {
  createInterface,
  encodeFunctionInput,
  decodeFunctionInput,
  decodeFunctionOutput,
  encodeEventLog,
  decodeEventLog,
  parseLog
};

// src/certificate/certificate.ts
var import_sdk_errors21 = require("@vechain/sdk-errors");
var import_fast_json_stable_stringify = __toESM(require("fast-json-stable-stringify"));

// src/vcdm/account/Account.ts
var import_sdk_errors4 = require("@vechain/sdk-errors");
var Account = class {
  address;
  balance;
  // Replace the string array with a Transaction class #1162
  transactions;
  type;
  constructor(address, balance, type = "EOA", transactions) {
    this.address = address;
    this.balance = balance;
    this.type = type;
    this.transactions = transactions ?? [];
  }
  /**
   * Throws an exception because the account cannot be represented as a big integer.
   * @returns {bigint} The BigInt representation of the account.
   * @throws {InvalidOperation} The account cannot be represented as a bigint.
   * @override {@link VeChainDataModel#bi}
   * @remarks The conversion to BigInt is not supported for an account.
   */
  get bi() {
    throw new import_sdk_errors4.InvalidOperation(
      "Account.bi",
      "There is no big integer representation for an account.",
      { data: "" }
    );
  }
  /**
   * Throws an exception because the account cannot be represented as a byte array.
   * @returns {Uint8Array} The byte array representation of the account.
   * @throws {InvalidOperation} The account cannot be represented as a byte array.
   * @override {@link VeChainDataModel#bytes}
   * @remarks The conversion to byte array is not supported for an account.
   */
  get bytes() {
    throw new import_sdk_errors4.InvalidOperation(
      "Account.bytes",
      "There is no bytes representation for an account.",
      { data: "" }
    );
  }
  /**
   * Throws an exception because the account cannot be represented as a number.
   * @returns {bigint} The number representation of the account.
   * @throws {InvalidOperation} The account cannot be represented as a number.
   * @override {@link VeChainDataModel#n}
   * @remarks The conversion to number is not supported for an account.
   */
  get n() {
    throw new import_sdk_errors4.InvalidOperation(
      "Account.n",
      "There is no number representation for an account.",
      { data: "" }
    );
  }
  /**
   * Adds a transaction to the account.
   * @param {string} transaction The transaction to add.
   */
  addTransaction(transaction) {
    this.transactions.push(transaction);
  }
  /**
   * Compare this instance with `that` in a meaningful way.
   *
   * @param {Account} that object to compare.
   * @return a negative number if `this` < `that`, zero if `this` = `that`, a positive number if `this` > that`.
   * @override {@link VeChainDataModel#compareTo}
   */
  compareTo(that) {
    const typeCompareTo = this.type.localeCompare(that.type);
    if (typeCompareTo !== 0) {
      return typeCompareTo;
    }
    const addressCompareTo = this.address.compareTo(that.address);
    if (addressCompareTo !== 0) {
      return addressCompareTo;
    }
    return this.balance.compareTo(that.balance);
  }
  /**
   * Checks if the given value is equal to the current instance.
   *
   * @param {Account} that - The value to compare.
   * @returns {boolean} - True if the values are equal, false otherwise.
   * @override {@link VeChainDataModel#isEqual}
   */
  isEqual(that) {
    return this.compareTo(that) === 0;
  }
  /**
   * Returns a string representation of the account.
   *
   * @returns {string} A string representation of the account.
   */
  toString() {
    return `${this.type} Address: ${this.address.toString()} Balance: ${this.balance.bi.toString()}`;
  }
};

// src/vcdm/hash/Keccak256.ts
var import_sha3 = require("@noble/hashes/sha3");
var import_sdk_errors8 = require("@vechain/sdk-errors");

// src/vcdm/Hex.ts
var nc_utils = __toESM(require("@noble/curves/abstract/utils"));
var nh_utils = __toESM(require("@noble/hashes/utils"));
var import_sdk_errors5 = require("@vechain/sdk-errors");
var Hex = class _Hex {
  /**
   * Negative multiplier of the {@link digits} absolute value.
   *
   * @type {number}
   */
  static NEGATIVE = -1;
  /**
   * Positive multiplier of the {@link digits} absolute value.
   *
   * @type {number}
   */
  static POSITIVE = 1;
  /**
   * The radix used for representing numbers base 16 in a positional numeral notation system.
   *
   * @typedef {number} RADIX
   */
  static RADIX = 16;
  /**
   * Regular expression for matching hexadecimal strings.
   * An empty input is represented as a empty digits.
   *
   * @type {RegExp}
   */
  static REGEX_HEX = /^-?(0x)?[0-9a-f]*$/i;
  /**
   * Regular expression pattern to match a prefix indicating hexadecimal number.
   *
   * @type {RegExp}
   */
  static REGEX_HEX_PREFIX = /^-?0x/i;
  /**
       * Returns the hexadecimal digits expressing this absolute value, sign and `0x` prefix omitted.
  
       * @remarks An empty content results in an empty string returned.
       */
  digits;
  /**
   * Represents the sign multiplier of a given number:
   * * {@link NEGATIVE} `-1` if negative,
   * * {@link POSITIVE} `1` if positive.
   */
  sign;
  /**
   * Creates a new instance of this class to represent the value
   * built multiplying `sign` for the absolute value expressed by the hexadecimal `digits`.
   *
   * @param {number} sign - The sign of the value.
   * @param {string} digits - The digits of the absolute value in hexadecimal base.
   * @param {function} [normalize] - The function used to normalize the digits. Defaults to converting digits to lowercase.
   */
  constructor(sign3, digits, normalize = (digits2) => digits2.toLowerCase()) {
    this.digits = normalize(digits);
    this.sign = sign3;
  }
  /**
   * Returns the absolute value of this Hex object.
   *
   * @return {Hex} A new Hex object representing the absolute value of this Hex.
   */
  get abs() {
    return new _Hex(_Hex.POSITIVE, this.digits);
  }
  /**
   * Returns the value of `bi` as a `BigInt` type.
   *
   * @returns {bigint} The value of `bi` as a `BigInt`.
   */
  get bi() {
    return BigInt(this.sign) * nc_utils.hexToNumber(this.digits);
  }
  /**
   * Returns the Uint8Array representation of the aligned bytes.
   *
   * @return {Uint8Array} The Uint8Array representation of the aligned bytes.
   */
  get bytes() {
    return nc_utils.hexToBytes(this.alignToBytes().digits);
  }
  /**
   * Returns the value of n.
   *
   * @return {number} The value of n.
   *
   * @throws {InvalidOperation<Hex>} Throws an error if this instance doesn't represent
   * an [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format).
   */
  get n() {
    if (this.isNumber()) {
      return new DataView(this.bytes.buffer).getFloat64(0);
    }
    throw new import_sdk_errors5.InvalidOperation("Hex.n", "not an IEEE 754 float 64 number", {
      hex: this.toString()
    });
  }
  /**
   * Aligns the hexadecimal string to bytes by adding a leading '0' if the string length is odd.
   *
   * @returns {Hex} - The aligned hexadecimal string.
   */
  alignToBytes() {
    return this.digits.length % 2 === 0 ? this : new _Hex(this.sign, "0" + this.digits);
  }
  /**
   * Compares the current Hex object with another Hex object.
   *
   * @param {Hex} that - The Hex object to compare with.
   *
   * @return {number} - Returns a negative number if the current Hex object is less than the given Hex object,
   *                    zero if they are equal, or a positive number if the current Hex object is greater than the given Hex object.
   */
  compareTo(that) {
    if (this.sign === that.sign) {
      const digits = Math.max(this.digits.length, that.digits.length);
      const thisBytes = this.fit(digits).bytes;
      const thatBytes = that.fit(digits).bytes;
      let i = 0;
      let compareByte = 0;
      while (compareByte === 0 && i < thisBytes.length) {
        compareByte = thisBytes[i] - thatBytes[i];
        i++;
      }
      return compareByte;
    }
    return this.sign - that.sign;
  }
  /**
   * Returns a new instance of the Hex class, its value fits to the specified number of digits.
   *
   * @param {number} digits - The number of digits to fit the Hex value into.
   *
   * @returns {Hex} - A new Hex instance that represents the fitted Hex value.
   *
   * @throws {InvalidDataType} - If the Hex value cannot be fit into the specified number of digits.
   */
  fit(digits) {
    if (digits < this.digits.length) {
      let cue = 0;
      while (this.digits.length - cue > digits && this.digits.at(cue) === "0") {
        cue++;
      }
      if (this.digits.length - cue === digits) {
        return new _Hex(this.sign, this.digits.slice(cue));
      }
      throw new import_sdk_errors5.InvalidDataType(
        "Hex.fit",
        `can't fit in ${digits} digits`,
        { digits, hex: this }
      );
    }
    if (digits > this.digits.length) {
      return new _Hex(
        this.sign,
        "0".repeat(digits - this.digits.length) + this.digits
      );
    }
    return this;
  }
  /**
   * Determines whether this Hex instance is equal to the given Hex instance.
   *
   * @param {Hex} that - The Hex instance to compare with.
   * @return {boolean} - True if the Hex instances are equal, otherwise false.
   */
  isEqual(that) {
    return this.compareTo(that) === 0;
  }
  /**
   * Checks if this instance expresses a valid {@link Number} value
   * according the
   * [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format).
   *
   * @returns {boolean} Returns true if this instance expresses 32 hex digits (16 bytes, 128 bits) needed to represent
   * a {@link Number} value, else it returns false.
   */
  isNumber() {
    return this.digits.length === 32;
  }
  /**
   * Checks if the given string expression is a valid hexadecimal value.
   *
   * @param {string} exp - The string representation of a hexadecimal value.
   *
   * @return {boolean} - True if the expression is a valid hexadecimal value, case-insensitive,
   * optionally prefixed with `0x`; false otherwise.
   */
  static isValid(exp) {
    return _Hex.REGEX_HEX.test(exp);
  }
  /**
   * Determines whether the given string is a valid hexadecimal number prefixed with '0x'.
   *
   * @param {string} exp - The string to be evaluated.
   * @return {boolean} - True if the string is a valid hexadecimal number prefixed with '0x', otherwise false.
   */
  static isValid0x(exp) {
    return _Hex.REGEX_HEX_PREFIX.test(exp) && _Hex.isValid(exp);
  }
  /**
   * Create a Hex instance from a bigint, number, string, or Uint8Array.
   *
   * @param {bigint | number | string | Uint8Array} exp - The value to represent in a Hex instance:
   * * bigint is always representable in hexadecimal base notation;
   * * number, encoded as [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format);
   * * string is parsed as the hexadecimal expression of a bigint value, optionally tagged with `0x`;
   * * Uint8Array is interpreted as the sequence of bytes.
   *
   * @returns {Hex} - A Hex instance representing the input value.
   *
   * @throws {InvalidDataType} if the given `exp` can't be represented as a hexadecimal expression.
   */
  static of(exp) {
    try {
      if (exp instanceof Uint8Array) {
        return new _Hex(this.POSITIVE, nc_utils.bytesToHex(exp));
      } else if (typeof exp === "bigint") {
        if (exp < 0n) {
          return new _Hex(
            this.NEGATIVE,
            nc_utils.numberToHexUnpadded(-1n * exp)
          );
        }
        return new _Hex(
          this.POSITIVE,
          nc_utils.numberToHexUnpadded(exp)
        );
      } else if (typeof exp === "number") {
        const dataView = new DataView(new ArrayBuffer(16));
        dataView.setFloat64(0, exp);
        return new _Hex(
          exp < 0 ? this.NEGATIVE : this.POSITIVE,
          nc_utils.bytesToHex(new Uint8Array(dataView.buffer))
        );
      }
      if (this.isValid(exp)) {
        if (exp.startsWith("-")) {
          return new _Hex(
            this.NEGATIVE,
            this.REGEX_HEX_PREFIX.test(exp) ? exp.slice(3) : exp.slice(1)
          );
        }
        return new _Hex(
          this.POSITIVE,
          this.REGEX_HEX_PREFIX.test(exp) ? exp.slice(2) : exp
        );
      }
      throw new import_sdk_errors5.InvalidDataType("Hex.of", "not an hexadecimal string", {
        exp
      });
    } catch (e) {
      throw new import_sdk_errors5.InvalidDataType(
        "Hex.of",
        "not an hexadecimal expression",
        { exp: `${exp}` },
        // Needed to serialize bigint values.
        e
      );
    }
  }
  /**
   * Generates a random Hex value of the given number of bytes length.
   *
   * @param {number} bytes - The number of bytes to generate.
   * @throws {InvalidDataType} - If the bytes argument is not greater than 0.
   * @returns {Hex} - A randomly generated Hex value.
   *
   * @remarks Security auditable method, depends on
   * * [`nh_utils.randomBytes`](https://github.com/paulmillr/noble-hashes?tab=readme-ov-file#utils).
   */
  static random(bytes) {
    if (bytes > 0) {
      return _Hex.of(nh_utils.randomBytes(bytes));
    }
    throw new import_sdk_errors5.InvalidDataType("Hex.random", "bytes argument not > 0", {
      bytes
    });
  }
  /**
   * Error handler for Hex and its subclasses so we do not hide them.
   * To be used only for nested errors.
   *
   * @param error - The error to handle from the subclass.
   * @param methodName - The name of the method that threw the error.
   * @param {string} errorMessage - The error message to throw.
   * @param {ObjectErrorData} data - The data to include in the error.
   * @throws {InvalidDataType} - Throws an error with the given message and data.
   */
  static throwInvalidDataType(error, methodName, errorMessage, data) {
    if (error instanceof import_sdk_errors5.InvalidDataType) {
      throw error;
    }
    throw new import_sdk_errors5.InvalidDataType(methodName, errorMessage, data, error);
  }
  /**
   * Returns a string representation of the object.
   *
   * @return {string} The string representation of the object.
   */
  toString() {
    return (this.sign < 0 ? "-0x" : "0x") + this.digits;
  }
};

// src/vcdm/HexInt.ts
var import_sdk_errors6 = require("@vechain/sdk-errors");
var HexInt = class _HexInt extends Hex {
  /**
   * Retrieves the value of n cast from this instance interpreted as the hexadecimal expression of a bigint value.
   *
   * @return {number} The value of n.
   *
   * @throws {InvalidDataType} If n is not within the safe number range, if the number representation of this
   * instance results approximated.
   *
   * @remarks This class makes equal instances created from the same value as number or as bigint.
   */
  get n() {
    const bi = this.bi;
    if (Number.MIN_SAFE_INTEGER <= bi && bi <= Number.MAX_SAFE_INTEGER) {
      return Number(bi);
    }
    throw new import_sdk_errors6.InvalidDataType("HexInt.n", "not in the safe number range", {
      bi: `${bi}`,
      hex: this.toString()
    });
  }
  /**
   * Create a HexInt instance from a bigint, number, string, Uint8Array, or {@link Hex}.
   *
   * @param {bigint | number | string | Uint8Array | Hex} exp - The expression to be interpreted as an integer:
   * * bigint is always representable in hexadecimal base notation;
   * * number is converted to a bigint then represented in hexadecimal base notation;
   *   it throws {@link InvalidDataType} if not an integer value;
   * * string is parsed as the hexadecimal expression of a bigint value, optionally tagged with `0x`;
   * * Uint8Array is interpreted as the sequence of bytes expressing a bigint value;
   * * {@link Hex} is interpreted as expressing a bigint value.
   *
   * @returns {HexInt} - The new HexInt object representing the given `exp`.
   *
   * @throws {InvalidDataType} - If the given `exp` is not a valid hexadecimal integer expression,
   * if `exp` is a not integer number.
   *
   * @remarks This class makes equal instances created from the same value as number or as bigint.
   */
  static of(exp) {
    try {
      if (exp instanceof Hex) {
        return new _HexInt(exp.sign, exp.digits);
      }
      if (typeof exp === "number") {
        if (Number.isInteger(exp)) {
          const hex2 = Hex.of(BigInt(exp));
          return new _HexInt(hex2.sign, hex2.digits);
        }
        throw new import_sdk_errors6.InvalidDataType("HexInt.of", "not an integer", {
          exp
        });
      }
      const hex = Hex.of(exp);
      return new _HexInt(hex.sign, hex.digits);
    } catch (e) {
      throw new import_sdk_errors6.InvalidDataType(
        "HexInt.of",
        "not an hexadecimal integer expression",
        { exp: `${exp}`, e }
        // Needed to serialize bigint values.
      );
    }
  }
};

// src/vcdm/HexUInt.ts
var import_sdk_errors7 = require("@vechain/sdk-errors");
var HexUInt = class _HexUInt extends HexInt {
  /**
   * Regular expression for matching hexadecimal strings.
   * An empty input is represented as a empty digits.
   *
   * @type {RegExp}
   */
  static REGEX_HEXUINT = /^(0x)?[0-9a-f]*$/i;
  /**
   * Regular expression pattern to match a prefix indicating hexadecimal number.
   *
   * @type {RegExp}
   */
  static REGEX_HEXUINT_PREFIX = /^0x/i;
  /**
   * Checks if the given string expression is a valid unsigned hexadecimal value.
   *
   * @param {string} exp - The string representation of a hexadecimal value.
   *
   * @return {boolean} - True if the expression is a valid unsigned hexadecimal value, case-insensitive,
   * optionally prefixed with `0x`; false otherwise.
   */
  static isValid(exp) {
    return _HexUInt.REGEX_HEXUINT.test(exp);
  }
  /**
   * Determines whether the given string is a valid unsigned hexadecimal number prefixed with '0x'.
   *
   * @param {string} exp - The string to be evaluated.
   * @return {boolean} - True if the string is a valid unsigned hexadecimal number prefixed with '0x', otherwise false.
   */
  static isValid0x(exp) {
    return _HexUInt.REGEX_HEX_PREFIX.test(exp) && Hex.isValid(exp);
  }
  /**
   * Create a HexUInt instance from a bigint, number, string, Uint8Array, or {@link HexInt}.
   *
   * @param {bigint | number | string | Uint8Array | HexInt} exp - The expression to be interpreted as an unsigned integer:
   * * bigint is always representable in hexadecimal base notation,
   *   it throws {@link InvalidDataType} if not positive;
   * * number is converted to a bigint then represented in hexadecimal base notation,
   *   it throws {@link InvalidDataType} if not a positive integer value;
   * * string is parsed as the hexadecimal expression of a bigint value, optionally tagged with `0x`;
   *   it throws {@link InvalidDataType} if not positive;
   * * Uint8Array is interpreted as the sequence of bytes expressing a positive bigint value;
   * * {@link HexInt} is interpreted as expressing a bigint value,
   *   it throws {@link InvalidDataType} if not positive.
   *
   * @returns {HexUInt} he new HexInt object representing the given `exp`.
   *
   * @throws {InvalidDataType} If the given expression is not a valid hexadecimal positive integer expression.
   */
  static of(exp) {
    try {
      const hint = HexInt.of(exp);
      if (hint.sign >= Hex.POSITIVE) {
        return new _HexUInt(hint.sign, hint.digits);
      }
      throw new import_sdk_errors7.InvalidDataType(
        "HexUInt.of",
        "not positive",
        { exp: `${exp}` }
        // Needed to serialize bigint values.
      );
    } catch (e) {
      throw new import_sdk_errors7.InvalidDataType(
        "HexUInt.of",
        "not a hexadecimal positive integer expression",
        { exp: `${exp}`, e },
        // Needed to serialize bigint values.
        e
      );
    }
  }
};

// src/vcdm/hash/Keccak256.ts
var Keccak256 = class _Keccak256 extends HexUInt {
  /**
   * Generates the [SHA-3](https://en.wikipedia.org/wiki/SHA-3) [KECCAK 256](https://keccak.team/keccak.html) hash of the given input.
   *
   * @param {bigint | number | string | Uint8Array | Hex} exp - The input value to hash.
   *
   * @returns {Sha256} - The [KECCAK 256](https://keccak.team/keccak.html) hash of the input value.
   *
   * @throws {InvalidOperation} - If a hash error occurs.
   *
   * @remarks Security auditable method, depends on
   * * [`nh_keccak_256`](https://github.com/paulmillr/noble-hashes#sha3-fips-shake-keccak).
   */
  static of(exp) {
    try {
      const hash2 = (0, import_sha3.keccak_256)(HexUInt.of(exp).bytes);
      return new _Keccak256(Hex.POSITIVE, HexUInt.of(hash2).digits);
    } catch (e) {
      throw new import_sdk_errors8.InvalidOperation("Keccak256.of", "hash error", {
        exp: `${exp}`,
        // Needed to serialize bigint values.
        e
      });
    }
  }
};
function keccak256(data, returnType = "buffer") {
  return returnType === "buffer" ? Keccak256.of(Txt.of(data).bytes).bytes : Keccak256.of(Txt.of(data).bytes).toString();
}

// src/hdkey/HDKey.ts
var s_bip32 = __toESM(require("@scure/bip32"));
var s_bip39 = __toESM(require("@scure/bip39"));
var nc_utils3 = __toESM(require("@noble/curves/abstract/utils"));
var import_base = require("@scure/base");

// src/secp256k1/Secp256k1.ts
var nc_utils2 = __toESM(require("@noble/curves/abstract/utils"));
var import_utils = require("@noble/hashes/utils");
var import_secp256k1 = require("@noble/curves/secp256k1");
var import_sdk_errors9 = require("@vechain/sdk-errors");
var Secp256k1 = class _Secp256k1 {
  /**
   * This value is used to identify compressed public key.
   */
  static COMPRESSED_PREFIX = 2;
  /**
   * Represents the fixed length of the cryptographic signature.
   * The value is set to 65, which is the size in bytes
   * required for a 520-bit signature.
   *
   * @constant {number} SIGNATURE_LENGTH
   */
  static SIGNATURE_LENGTH = 65;
  /**
   * This value is used to identify uncompressed public key.
   */
  static UNCOMPRESS_PREFIX = 4;
  /**
   * Defines the required length for a valid hash.
   */
  static VALID_HASH_LENGTH = 32;
  /**
   * Compresses an uncompressed public key.
   *
   * @param {Uint8Array} publicKey - The uncompressed public key to be compressed.
   * @return {Uint8Array} - The compressed public key.
   *
   * @see Secp256k1.inflatePublicKey
   */
  static compressPublicKey(publicKey) {
    const prefix = publicKey.at(0);
    if (prefix === _Secp256k1.UNCOMPRESS_PREFIX) {
      const x = publicKey.slice(1, 33);
      const y = publicKey.slice(33, 65);
      const isYOdd = y[y.length - 1] & 1;
      return nc_utils2.concatBytes(
        Uint8Array.of(_Secp256k1.COMPRESSED_PREFIX + isYOdd),
        x
      );
    } else {
      return publicKey;
    }
  }
  /**
   * Derives the public key from a given private key.
   *
   * @param {Uint8Array} privateKey - The private key in Uint8Array format. Must be a valid 32-byte secp256k1 private key.
   * @param {boolean} [isCompressed=true] - Indicates whether the derived public key should be in compressed format.
   * @return {Uint8Array} The derived public key in Uint8Array format.
   * @throws {InvalidSecp256k1PrivateKey} Throws an error if the provided private key is not valid.
   *
   * @remarks Security auditable method, depends on
   * * [nc_secp256k1.getPublicKey](https://github.com/paulmillr/noble-secp256k1).
   */
  static derivePublicKey(privateKey, isCompressed = true) {
    if (_Secp256k1.isValidPrivateKey(privateKey)) {
      return import_secp256k1.secp256k1.getPublicKey(privateKey, isCompressed);
    }
    throw new import_sdk_errors9.InvalidSecp256k1PrivateKey(
      "Secp256k1.derivePublicKey",
      "Invalid private key given as input. Ensure it is a valid 32-byte secp256k1 private key.",
      void 0
    );
  }
  /**
   * Generates a new random private key.
   * If an error occurs during generation using
   * [nc_secp256k1](https://github.com/paulmillr/noble-secp256k1),
   * an AES-GCM key is generated as a fallback in runtimes not supported
   * by `nc_secp256k1`, if those support {@link {@link global.crypto}.
   *
   * @return {Promise<Uint8Array>} The generated private key as a Uint8Array.
   *
   * @remarks Security auditable method, depends on
   * * {@link global.crypto.subtle.exportKey};
   * * {@link global.crypto.subtle.generateKey};
   * * [nc_secp256k1.utils.randomPrivateKey](https://github.com/paulmillr/noble-secp256k1).
   */
  static async generatePrivateKey() {
    try {
      return import_secp256k1.secp256k1.utils.randomPrivateKey();
    } catch (error) {
      const cryptoKey = await global.crypto.subtle.generateKey(
        {
          name: "AES-GCM",
          length: 256
        },
        true,
        ["encrypt", "decrypt"]
      );
      const rawKey = await global.crypto.subtle.exportKey(
        "raw",
        cryptoKey
      );
      return new Uint8Array(rawKey);
    }
  }
  /**
   * Inflate a compressed public key to its uncompressed form.
   *
   * @param {Uint8Array} publicKey - The compressed public key to be inflated.
   * @return {Uint8Array} - The uncompressed public key.
   *
   * @remarks Security auditable method, depends on
   * * [nc_secp256k1.ProjectivePoint.fromAffine](https://github.com/paulmillr/noble-secp256k1);
   * * [nc_secp256k1.ProjectivePoint.fromHex](https://github.com/paulmillr/noble-secp256k1);
   * * [nc_secp256k1.ProjectivePoint.toAffine](https://github.com/paulmillr/noble-secp256k1).
   *
   * @see Secp256K1.compressPublicKey
   */
  static inflatePublicKey(publicKey) {
    const prefix = publicKey.at(0);
    if (prefix !== _Secp256k1.UNCOMPRESS_PREFIX) {
      const x = publicKey.slice(0, 33);
      const p = import_secp256k1.secp256k1.ProjectivePoint.fromAffine(
        import_secp256k1.secp256k1.ProjectivePoint.fromHex(
          HexUInt.of(x).digits
        ).toAffine()
      );
      return p.toRawBytes(false);
    } else {
      return publicKey;
    }
  }
  /**
   * Checks whether the provided hash is a valid message hash.
   *
   * @param {Uint8Array} hash - The hash to be validated.
   * @return {boolean} `true` if the hash is 32 bytes long, otherwise `false`.
   */
  static isValidMessageHash(hash2) {
    return hash2.length === _Secp256k1.VALID_HASH_LENGTH;
  }
  /**
   * Checks if the provided private key is valid.
   *
   * @param {Uint8Array} privateKey - The private key to validate.
   * @return {boolean} `true` if the private key is valid, `false` otherwise.
   *
   * @remarks Security auditable method, depends on
   * * [nc_secp256k1.utils.isValidPrivateKey](https://github.com/paulmillr/noble-secp256k1).
   */
  static isValidPrivateKey(privateKey) {
    return import_secp256k1.secp256k1.utils.isValidPrivateKey(privateKey);
  }
  /**
   * Generates a random sequence of bytes.
   * If an error occurs during generation using
   * [nc_secp256k1](https://github.com/paulmillr/noble-secp256k1),
   * {@link {@link global.crypto} is used as fall back togenerate
   * the random sequence.
   *
   * @param {number} [bytesLength=32] - Optional. The number of random bytes to generate.
   * @return {Uint8Array} - A Uint8Array containing the random bytes.
   *
   * @remarks Security auditable method, depends on
   *  * {@link global.crypto.getRandomValues};
   * * [nh_randomBytes](https://github.com/paulmillr/noble-hashes).
   */
  static randomBytes(bytesLength) {
    try {
      return (0, import_utils.randomBytes)(bytesLength);
    } catch (error) {
      return global.crypto.getRandomValues(
        new Uint8Array(bytesLength ?? 32)
      );
    }
  }
  /**
   * Recovers the public key associated with the message hash from the given signature.
   *
   * @param {Uint8Array} messageHash - The 32-byte message hash to be verified.
   * @param {Uint8Array} sig - The 65-byte signature used for recovery, consisting of the compact signature and recovery byte.
   * @return {Uint8Array} The recovered public key in its raw bytes form.
   * @throws {InvalidSecp256k1MessageHash} If the provided message hash is invalid.
   * @throws {InvalidSecp256k1Signature} If the provided signature is not 65 bytes or contains an invalid recovery value.
   *
   * @remarks Security auditable method, depends on
   * * [nc_secp256k1.Signature](https://github.com/paulmillr/noble-secp256k1).
   *
   * @see Secp256k1.isValidMessageHash
   */
  static recover(messageHash, sig) {
    if (!_Secp256k1.isValidMessageHash(messageHash)) {
      throw new import_sdk_errors9.InvalidSecp256k1MessageHash(
        "Secp256k1.recover",
        "Invalid message hash given as input. Ensure it is a valid 32-byte message hash.",
        { messageHash }
      );
    }
    if (sig.length !== _Secp256k1.SIGNATURE_LENGTH)
      throw new import_sdk_errors9.InvalidSecp256k1Signature(
        "Secp256k1.recover",
        "Invalid signature given as input. Length must be exactly 65 bytes.",
        { signature: sig }
      );
    const recovery = sig[64];
    if (recovery !== 0 && recovery !== 1)
      throw new import_sdk_errors9.InvalidSecp256k1Signature(
        "Secp256k1.recover",
        "Invalid signature recovery value. Signature bytes at position 64 must be 0 or 1.",
        { signature: sig, recovery }
      );
    return import_secp256k1.secp256k1.Signature.fromCompact(sig.slice(0, 64)).addRecoveryBit(recovery).recoverPublicKey(messageHash).toRawBytes(false);
  }
  /**
   * Signs a given message hash using the provided private key.
   *
   * @param messageHash - A 32-byte message hash that needs to be signed.
   * @param privateKey - A 32-byte private key used for signing the message hash.
   * @return The signature of the message hash consisting of the r, s, and recovery values.
   * @throws InvalidSecp256k1MessageHash if the message hash is not a valid 32-byte hash.
   * @throws InvalidSecp256k1PrivateKey if the private key is not a valid 32-byte private key.
   *
   * @remarks Security auditable method, depends on
   * * [nc_secp256k1.sign](https://github.com/paulmillr/noble-secp256k1).
   *
   * @see Secp256k1.isValidMessageHash
   * @see Secp256k1.isValidPrivateKey
   */
  static sign(messageHash, privateKey) {
    if (!_Secp256k1.isValidMessageHash(messageHash)) {
      throw new import_sdk_errors9.InvalidSecp256k1MessageHash(
        "Secp256k1.sign",
        "Invalid message hash given as input. Ensure it is a valid 32-byte message hash.",
        { messageHash }
      );
    }
    if (!_Secp256k1.isValidPrivateKey(privateKey)) {
      throw new import_sdk_errors9.InvalidSecp256k1PrivateKey(
        "Secp256k1.sign",
        "Invalid private key given as input. Ensure it is a valid 32-byte secp256k1 private key.",
        void 0
      );
    }
    const sig = import_secp256k1.secp256k1.sign(messageHash, privateKey);
    return nc_utils2.concatBytes(
      nc_utils2.numberToBytesBE(sig.r, 32),
      nc_utils2.numberToBytesBE(sig.s, 32),
      nc_utils2.numberToVarBytesBE(sig.recovery)
    );
  }
};

// src/vcdm/hash/Sha256.ts
var nh_sha256 = __toESM(require("@noble/hashes/sha256"));
var import_sdk_errors10 = require("@vechain/sdk-errors");
var Sha256 = class _Sha256 extends HexUInt {
  /**
   * Generates the [SHA 256](https://en.wikipedia.org/wiki/SHA-2) hash of the given input.
   *
   * @param {bigint | number | string | Uint8Array | Hex} exp - The input value to hash.
   *
   * @returns {Sha256} - The [SHA256](https://en.wikipedia.org/wiki/SHA-2) hash of the input value.
   *
   * @throws {InvalidOperation} - If a hash error occurs.
   *
   * @remarks Security auditable method, depends on
   * * [`nh_sha256.sha256`](https://github.com/paulmillr/noble-hashes#sha2-sha256-sha384-sha512-and-others).
   */
  static of(exp) {
    try {
      const hash2 = nh_sha256.sha256(HexUInt.of(exp).bytes);
      return new _Sha256(Hex.POSITIVE, HexUInt.of(hash2).digits);
    } catch (e) {
      throw new import_sdk_errors10.InvalidOperation("Sha256.of", "hash error", {
        exp: `${exp}`,
        // Needed to serialize bigint values.
        e
      });
    }
  }
};
function sha2562(data, returnType = "buffer") {
  return returnType === "buffer" ? Sha256.of(Txt.of(data).bytes).bytes : Sha256.of(Txt.of(data).bytes).toString();
}

// src/hdkey/HDKey.ts
var import_sdk_errors11 = require("@vechain/sdk-errors");
var HDKey2 = class extends s_bip32.HDKey {
  /**
   * Prefix for extended private key
   */
  static EXTENDED_PRIVATE_KEY_PREFIX = HexUInt.of(
    "0488ade4000000000000000000"
  ).bytes;
  /**
   * Prefix for extended public key
   */
  static EXTENDED_PUBLIC_KEY_PREFIX = HexUInt.of(
    "0488b21e000000000000000000"
  ).bytes;
  /**
   * Default VET derivation path.
   *
   * See
   * [SLIP-0044 : Registered coin types for BIP-0044](https://github.com/satoshilabs/slips/blob/master/slip-0044.md)
   * for more info.
   */
  static VET_DERIVATION_PATH = "m/44'/818'/0'/0";
  /**
   * Creates a
   * [BIP32 Hierarchical Deterministic Key](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
   * from
   * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
   * and the given derivation path.
   *
   * @param {string[]} words An array of words representing the mnemonic.
   * @param {string} path The derivation path to derive the child node.
   * Default value is {@link VET_DERIVATION_PATH}.
   *
   * @return The derived child hierarchical deterministic key.
   *
   * @throws {InvalidHDKey} If `path` is not valid to derive a node wallet.
   * @throws {InvalidHDKeyMnemonic} If `words` is an invalid array mnemonic.
   *
   * @remarks Security auditable method, depends on
   * * [s_bip32.HDKey.derive](https://github.com/paulmillr/scure-bip32);
   * * [s_bip32.HDKey.fromMasterSeed](https://github.com/paulmillr/scure-bip32);
   * * [s_bip39.mnemonicToSeedSync](https://github.com/paulmillr/scure-bip39).
   */
  static fromMnemonic(words, path = this.VET_DERIVATION_PATH) {
    let master;
    try {
      master = s_bip32.HDKey.fromMasterSeed(
        s_bip39.mnemonicToSeedSync(words.join(" ").toLowerCase())
      );
    } catch (error) {
      throw new import_sdk_errors11.InvalidHDKeyMnemonic(
        "HDNode.fromMnemonic",
        "Invalid mnemonic words given as input.",
        void 0,
        error
      );
    }
    try {
      return master.derive(path);
    } catch (error) {
      throw new import_sdk_errors11.InvalidHDKey(
        "HDNode.fromMnemonic",
        "Invalid derivation path given as input.",
        { derivationPath: path },
        error
      );
    }
  }
  /**
   * Creates a
   * [BIP32 Hierarchical Deterministic Key](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
   * from a private key and chain code.
   *
   * @param {Uint8Array} privateKey The private key.
   * @param {Uint8Array} chainCode The chain code.
   *
   * @returns Returns the hierarchical deterministic key from `privateKey` and `chainCode`.
   *
   * @throws {InvalidSecp256k1PrivateKey} If the `privateKey` is invalid.
   *
   * @remarks **This method wipes `privateKey`** for security reasons.
   * @remarks Security auditable method, depends on
   * * [base58.encode](https://github.com/paulmillr/scure-base);
   * * {@link Sha256};
   * * [s_bip32.HDKey.fromExtendedKey](https://github.com/paulmillr/scure-bip32).
   */
  static fromPrivateKey(privateKey, chainCode) {
    if (privateKey.length === 32) {
      const header = nc_utils3.concatBytes(
        this.EXTENDED_PRIVATE_KEY_PREFIX,
        chainCode,
        Uint8Array.of(0),
        privateKey
      );
      privateKey.fill(0);
      const checksum = Sha256.of(Sha256.of(header).bytes).bytes.subarray(
        0,
        4
      );
      const expandedPrivateKey = nc_utils3.concatBytes(header, checksum);
      try {
        return s_bip32.HDKey.fromExtendedKey(
          import_base.base58.encode(expandedPrivateKey)
        );
      } catch (error) {
        throw new import_sdk_errors11.InvalidSecp256k1PrivateKey(
          "HDNode.fromPrivateKey",
          "Invalid private key path given as input.",
          void 0
        );
      }
    }
    privateKey.fill(0);
    throw new import_sdk_errors11.InvalidSecp256k1PrivateKey(
      "HDNode.fromPrivateKey()",
      "Invalid private key path given as input. Length must be exactly 32 bytes.",
      void 0
    );
  }
  /**
   * Creates a
   * [BIP32 Hierarchical Deterministic Key](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
   * key from a public key and chain code.
   *
   * @param {Uint8Array} publicKey The public key bytes.
   * @param {Uint8Array} chainCode The chain code bytes.
   *
   * @returns {bip32.HDKey} Returns the hierarchical deterministic key from `public` and `chainCode`.
   *
   * @throws {InvalidHDKey} if the `publicKey` is invalid.
   *
   * @remarks Security auditable method, depends on
   * * [base58.encode](https://github.com/paulmillr/scure-base);
   * * {@link Secp256k1.compressPublicKey};
   * * {@link Sha256};
   * * [s_bip32.HDKey.fromExtendedKey](https://github.com/paulmillr/scure-bip32).
   */
  static fromPublicKey(publicKey, chainCode) {
    if (chainCode.length === 32) {
      const header = nc_utils3.concatBytes(
        this.EXTENDED_PUBLIC_KEY_PREFIX,
        chainCode,
        Secp256k1.compressPublicKey(publicKey)
      );
      const checksum = Sha256.of(Sha256.of(header).bytes).bytes.subarray(
        0,
        4
      );
      const expandedPublicKey = nc_utils3.concatBytes(header, checksum);
      try {
        return s_bip32.HDKey.fromExtendedKey(
          import_base.base58.encode(expandedPublicKey)
        );
      } catch (error) {
        throw new import_sdk_errors11.InvalidHDKey(
          "HDNode.fromPublicKey()",
          "Invalid public key path given as input.",
          { publicKey },
          error
        );
      }
    }
    throw new import_sdk_errors11.InvalidHDKey(
      "HDNode.fromPublicKey()",
      "Invalid chain code given as input. Length must be exactly 32 bytes.",
      { chainCode }
    );
  }
  /**
   * Checks if derivation path single component is valid
   *
   * @param component - Derivation path single component to check
   * @param index - Derivation path single component index
   *
   * @returns `true`` if derivation path single component is valid, otherwise `false`.
   *
   */
  static isDerivationPathComponentValid(component, index) {
    return (
      // m
      (index === 0 ? component === "m" : false) || // "number"
      FPN.isNaturalExpression(component) || // "number'"
      FPN.isNaturalExpression(component.slice(0, -1)) && component.endsWith("'")
    );
  }
  /**
   * Checks if derivation path is valid.
   *
   * @param derivationPath - Derivation path to check.
   *
   * @returns `true` if derivation path is valid, otherwise `false`.
   */
  static isDerivationPathValid(derivationPath) {
    const pathComponents = derivationPath.split("/");
    for (let i = 0; i < pathComponents.length; i++) {
      if (!this.isDerivationPathComponentValid(pathComponents[i], i))
        return false;
    }
    return true;
  }
};

// src/vcdm/Txt.ts
var import_sdk_errors12 = require("@vechain/sdk-errors");
var Txt = class _Txt extends String {
  /**
   * Decoder object used for decoding bytes as text data.
   *
   * @class
   * @constructor
   */
  static DECODER = new TextDecoder();
  /**
   * *Normalization Form Canonical Composition*
   * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence)
   * flag.
   *
   * @type {string}
   * @constant
   */
  static NFC = "NFC";
  /**
   * A TextEncoder instance used for encoding text to bytes.
   *
   * @type {TextEncoder}
   */
  static ENCODER = new TextEncoder();
  /**
   * Creates a new instance of this class representing the `exp` string
   * normalized according the *Canonical Composition Form*
   * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence).
   *
   * @param {string} exp - The expression to be passed to the constructor.
   * @protected
   * @constructor
   */
  constructor(exp) {
    super(exp.normalize(_Txt.NFC));
  }
  /**
   * Converts the current Txt string to a BigInt.
   *
   * @returns {bigint} The BigInt representation of the Txt string.
   *
   *  @throws {InvalidOperation} If the conversion to BigInt fails because this Txt string doesn't represent an integer.
   */
  get bi() {
    try {
      return BigInt(this.toString());
    } catch (e) {
      throw new import_sdk_errors12.InvalidOperation(
        "Txt.bi()",
        "Can't cast to big integer",
        { txt: this.toString() },
        e
      );
    }
  }
  /**
   * Converts the current Txt string to a buffer of bytes.
   *
   * @returns {Uint8Array} The bytes representation of the Txt string.
   */
  get bytes() {
    return _Txt.ENCODER.encode(this.toString());
  }
  /**
   * Returns the value of n as a number.
   *
   * @returns {number} The value of n as a number.
   */
  /**
   * Converts the current Txt string to a number.
   *
   * @returns {number} The numeric value of the Txt string.
   *
   * @throws {InvalidOperation} If the conversion to number fails because this Txt string doesn't represent a decimal number.
   */
  get n() {
    return Number(this.toString());
  }
  /**
   * Compares the current instance to another instance of Txt.
   *
   * @param {Txt} that - The instance to compare with.
   *
   * @return {number} - A negative number if the current instance is less than the specified instance,
   *                    zero if they are equal, or a positive number if the current instance is greater.
   */
  compareTo(that) {
    return this.toString().localeCompare(that.toString());
  }
  /**
   * Checks if the current Txt object is equal to the given Txt object.
   *
   * @param {Txt} that - The Txt object to compare with.
   *
   *  @return {boolean} - True if the objects are equal, false otherwise.
   */
  isEqual(that) {
    return this.compareTo(that) === 0;
  }
  /**
   * Returns a string representation of the object.
   *
   * @returns {string} A string representation of the object.
   */
  toString() {
    return this.valueOf();
  }
  /**
   * Creates a new Txt instance from the provided expression.
   *
   * @param {bigint | number | string | Uint8Array} exp - The expression to convert to Txt:
   * * {@link bigint} is represented as a {@link NFC} encoded string expressing the value in base 10;
   * * {@link number} is represented as a {@link NFC} encoded string expressing the value in base 10;
   * * {@link string} is encoded as {@link NFC} string;
   * * {@link Uint8Array} is {@link NFC} decoded to a string.
   *
   * @returns {Txt} - A new Txt instance.
   */
  static of(exp) {
    if (exp instanceof Uint8Array) {
      return new _Txt(_Txt.DECODER.decode(exp));
    } else if (typeof exp === "bigint" || typeof exp === "number") {
      return new _Txt(exp.toString());
    }
    return new _Txt(exp);
  }
};

// src/vcdm/Address.ts
var import_sdk_errors13 = require("@vechain/sdk-errors");
var Address = class _Address extends HexUInt {
  /**
   * It checksums a given hexadecimal address.
   *
   * @param {HexUInt} huint The HexUInt object representing the hexadecimal value.
   *
   * @returns {string} The checksummed address.
   */
  static checksum(huint) {
    const stringAddress = huint.digits;
    const hash2 = Keccak256.of(Txt.of(stringAddress).bytes).digits;
    let checksum = "";
    for (let i = 0; i < stringAddress.length; i++) {
      checksum += parseInt(hash2[i], 16) > 7 ? stringAddress[i].toUpperCase() : stringAddress[i];
    }
    return "0x" + checksum;
  }
  /**
   * Validate the given expression to be a valid address.
   *
   *  @param {string} exp Expression to validate
   *
   * @returns {boolean} true if the expression is a valid address, false otherwise
   */
  static isValid(exp) {
    return Hex.isValid0x(exp) && exp.length === 42;
  }
  /**
   * Create ab Address instance from the given expression interpreted as an unsigned integer.
   *
   * @param exp The expression to convert. It can be of type bigint, number, string, Uint8Array, or HexUInt.
   *
   * @returns {Address} The converted hexadecimal unsigned integer.
   *
   * @throws {InvalidDataType} If the expression is not a valid hexadecimal positive integer expression.
   */
  static of(exp) {
    try {
      const huint = HexUInt.of(exp);
      if (_Address.isValid(huint.toString())) {
        const addressChecksummed = _Address.checksum(huint);
        return new _Address(
          Hex.POSITIVE,
          "0x0",
          // When we normalize we return the checksummed address as digits
          () => addressChecksummed.substring(2)
        );
      } else {
        throw new import_sdk_errors13.InvalidDataType("Address.of", "not a valid address", {
          huint
        });
      }
    } catch (error) {
      this.throwInvalidDataType(
        error,
        "Address.of",
        "not a valid hexadecimal positive integer expression",
        { exp: `${exp}`, error }
      );
    }
  }
  /**
   * Create an Address instance from the given private key.
   *
   * @param {Uint8Array} privateKey The private key to convert.
   *
   * @param {boolean} [isCompressed=true] The flag to indicate if the derived public key should be compressed.
   *
   * @returns {Address} The converted address.
   *
   * @remarks Security auditable method, depends on
   * * {@link Secp256k1.derivePublicKey}.
   */
  static ofPrivateKey(privateKey, isCompressed = true) {
    try {
      return _Address.ofPublicKey(
        Secp256k1.derivePublicKey(privateKey, isCompressed)
      );
    } catch (error) {
      if (error instanceof import_sdk_errors13.InvalidSecp256k1PrivateKey) {
        throw error;
      }
      this.throwInvalidDataType(
        error,
        "Address.ofPrivateKey",
        "not a valid private key",
        { privateKey: `${privateKey}`, error }
      );
    }
  }
  /**
   * Create an Address instance from the given public key.
   *
   * @param {Uint8Array} publicKey The public key to convert.
   *
   * @returns {Address} The converted address.
   *
   * @remarks Security auditable method, depends on
   * * {@link Secp256k1.inflatePublicKey}.
   */
  static ofPublicKey(publicKey) {
    try {
      const publicKeyInflated = Secp256k1.inflatePublicKey(publicKey);
      const publicKeyHash = Keccak256.of(
        publicKeyInflated.slice(1)
      ).bytes;
      return _Address.of(publicKeyHash.slice(12));
    } catch (error) {
      this.throwInvalidDataType(
        error,
        "Address.ofPublicKey",
        "not a valid public key",
        { publicKey: `${publicKey}`, error }
      );
    }
  }
  /**
   * Derives the address from a given list of words of
   * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
   * and a [BIP44 Derivation Path](https://github.com/satoshilabs/slips/blob/master/slip-0044.md)
   * as in the examples.
   *
   * Secure audit function.
   * - {@link bip32.HDKey}(https://github.com/paulmillr/scure-bip32)
   * - {@link HDKey}
   *
   * @example `m/0` (default)
   * @example `m/0/2`
   * @example `m/0/2/4/6`
   *
   * @param {string[]} mnemonic - Mnemonic used to generate the HD node.
   * @param {string} [path='m/0'] - The derivation path from the current node.
   * @return {Address} - The derived address.
   * @throws {InvalidHDKey}
   *
   */
  static ofMnemonic(mnemonic2, path = "m/0") {
    const root = HDKey2.fromMnemonic(mnemonic2);
    try {
      return _Address.ofPublicKey(
        root.derive(path).publicKey
      );
    } catch (error) {
      throw new import_sdk_errors13.InvalidHDKey(
        "mnemonic.deriveAddress()",
        "Invalid derivation path given as input.",
        { derivationPath: path },
        error
      );
    }
  }
};
var addressUtils = {
  fromPrivateKey: (privateKey) => Address.ofPrivateKey(privateKey).toString(),
  fromPublicKey: (publicKey) => Address.ofPublicKey(publicKey).toString(),
  isAddress: (addressToVerify) => Address.isValid(addressToVerify),
  toERC55Checksum: (address) => Address.checksum(HexUInt.of(address)).toString()
};

// src/vcdm/BloomFilter.ts
var nc_utils4 = __toESM(require("@noble/curves/abstract/utils"));

// src/vcdm/hash/Blake2b256.ts
var import_blake2b = require("@noble/hashes/blake2b");
var import_sdk_errors14 = require("@vechain/sdk-errors");
var Blake2b256 = class _Blake2b256 extends HexUInt {
  /**
   * Generates the [BLAKE](https://en.wikipedia.org/wiki/BLAKE_(hash_function)) [BLAKE2B 256](https://www.blake2.net/) hash of the given input.
   *
   * @param {bigint | number | string | Uint8Array | Hex} exp - The input value to hash.
   *
   * @returns {Sha256} - The [BLAKE2B 256](https://www.blake2.net/) hash of the input value.
   *
   * @throws {InvalidOperation} - If a hash error occurs.
   *
   * @remarks Security auditable method, depends on
   * * [`nh_blake2b.create(...).update(...).digest(...)`](https://github.com/paulmillr/noble-hashes#sha3-fips-shake-keccak).
   */
  static of(exp) {
    try {
      const hash2 = import_blake2b.blake2b.create({ dkLen: 32 }).update(HexUInt.of(exp).bytes).digest();
      return new _Blake2b256(Hex.POSITIVE, HexUInt.of(hash2).digits);
    } catch (e) {
      throw new import_sdk_errors14.InvalidOperation("Blake2b256.of", "hash error", {
        exp: `${exp}`,
        // Needed to serialize bigint values.
        e
      });
    }
  }
};
function blake2b256(data, returnType = "buffer") {
  return returnType === "buffer" ? Blake2b256.of(Txt.of(data).bytes).bytes : Blake2b256.of(Txt.of(data).bytes).toString();
}

// src/vcdm/BloomFilter.ts
var import_sdk_errors15 = require("@vechain/sdk-errors");
var BloomFilter = class _BloomFilter {
  /**
   * Return the Bloom filter structure: an array of `m` bits per key encoding if a key is not part of the structure.
   *
   * @typedef {Uint8Array} bytes
   */
  bytes;
  /**
   * Return the number of hash functions used to compute this Bloom filter.
   *
   * @type {number}
   */
  k;
  /**
   * Creates a new instance of this class.
   *
   * @param {Uint8Array} bytes - The Bloom filter structure of `m` bits per key encoding if the key
   *                             likely belongs to the structure or surely doesn't.
   * @param {number} k - The number of hash functions used to compute this Bloom filter.
   *
   */
  constructor(bytes, k) {
    this.bytes = bytes;
    this.k = k;
  }
  /**
   * Return the Bloom filter data structure represented as a {@link bigint} value.
   *
   * @returns {bigint} - The Bloom filter data structure represented as a {@link bigint} value.
   */
  get bi() {
    return nc_utils4.bytesToNumberBE(this.bytes);
  }
  /**
   * Return the Bloom filter data structure represented as a {@link number} value.
   *
   * @returns {bigint} - The Bloom filter data structure represented as a {@link number} value.
   *
   * @throws InvalidDataType if the data structure of the bloom filter can't be represented as a number
   * because underflow or overflow number safe integer range according
   * [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format).
   *
   * @remarks Preferably use {@link bi} because the Bloom filter data structure can always be represented as a {@link bigint} value.
   */
  get n() {
    const bi = this.bi;
    if (Number.MIN_SAFE_INTEGER <= bi && bi <= Number.MAX_SAFE_INTEGER) {
      return Number(bi);
    }
    throw new import_sdk_errors15.InvalidDataType(
      "BloomFilter.n",
      "not in the safe number range",
      {
        bytes: this.bytes,
        k: this.k
      }
    );
  }
  /**
   * Compare the current BloomFilter instance with another BloomFilter instance according their
   * * {@link bytes} data structure first,
   * * {@link k} if the data structures are equal.
   *
   * @param {BloomFilter} that - The BloomFilter instance to compare with.
   *
   * @return {number} - Returns a negative number if the current instance is less than the provided instance,
   *                   returns zero if they are equal, and returns a positive number if the current instance is greater than the provided instance.
   */
  compareTo(that) {
    return this.bi < that.bi ? -1 : this.bi === that.bi ? this.k - that.k : 1;
  }
  /**
   * Checks if the current BloomFilter instance is equal to another BloomFilter instance.
   *
   * @param {BloomFilter} that - The other BloomFilter instance to compare with.
   *
   * @return {boolean} - Returns true if the current BloomFilter instance is equal to the other BloomFilter instance, otherwise returns false.
   */
  isEqual(that) {
    return this.bi === that.bi && this.k === that.k;
  }
  /**
   * Checks if the specified key may be contained within this Bloom filter or surely isn't.
   *
   * @param {Hex|Uint8Array} key - The key to check. It can be either a Hex object or a Uint8Array.
   *
   * @return {boolean} Returns true if this Bloom filter may contain the key, otherwise returns false.
   *
   * @remarks False positive matches are possible, but false negatives are not.
   * @remarks Security auditable method, depends on
   * * {@link hash}.
   */
  contains(key) {
    return distribute(
      hash(key instanceof Hex ? key.bytes : key),
      this.k,
      this.bytes.byteLength * 8,
      (index, bit) => {
        return (this.bytes[index] & bit) === bit;
      }
    );
  }
  /**
   * Calculates the optimal number of bits per key (`m` in math literature) based
   * on the number of hash functions (`k` in math literature) used to generate the Bloom Filter.
   *
   * Mathematically, `m` is approximated as `(k / ln(2))` which is simplified
   * to the higher integer close to `(m / 0.69)` for computational efficiency.
   * It also ensures that `k` is within a practical range [1, 30], hence the function
   * - returns `2` for `k = 1`,
   * - returns `44` for `k >= 30`.
   *
   * @param {number} k - The number of keys.
   *
   * @return {number} - The number of bits per key.
   */
  static computeBestBitsPerKey(k) {
    if (k <= 1) return 2;
    return k >= 30 ? 44 : Math.ceil(k / 0.69);
  }
  /**
   * Calculates the optimal number of hash functions (`k` in math literature)
   * based on bits per key (`m` in math literature).
   *
   * Mathematically, `k` is approximated as `(m * ln(2))` which is simplified
   * to the lower integer close to `(m * 0.69)` for computational efficiency.
   * It also ensures that `k` stays within a practical range [1, 30].
   *
   * @param m - The number of bits per key.
   *
   * @returns The calculated optimal `k` value.
   */
  static computeBestHashFunctionsQuantity(m) {
    const k = Math.floor(m * 0.69);
    if (k < 1) return 1;
    return k > 30 ? 30 : k;
  }
  /**
   * Checks if the current BloomFilter instance is possible to join with another BloomFilter instance.
   *
   * @param {BloomFilter} other - The BloomFilter instance to check if it is possible to join with the current instance.
   *
   * @return {boolean} - Returns true if the BloomFilter instances have the same 'k' value and 'bytes' length, false otherwise.
   */
  isJoinable(other) {
    return this.k === other.k && this.bytes.length === other.bytes.length;
  }
  /**
   * Joins the current BloomFilter with another BloomFilter by performing a bitwise OR operation on the
   * data structures of the filters.
   * Both filters must have been generated with the same number of hash functions, and they must have the same length.
   *
   * @param other - The BloomFilter to join with.
   *
   * @returns A new BloomFilter that represents the result of the join operation.
   *          They keys made this and `other` filter may belong to the returned filter.
   *          Any key not part of the joined filter surely doesn't belong to the returned filter.
   *
   * @throws {InvalidOperation} If the k values of the BloomFilters are different.
   * @throws {InvalidOperation} If the length of the byte arrays are different.
   */
  join(other) {
    if (this.k === other.k) {
      if (this.bytes.length === other.bytes.length) {
        return new _BloomFilter(
          new Uint8Array(
            this.bytes.map(
              (byte, index) => byte | other.bytes[index]
            )
          ),
          this.k
        );
      }
      throw new import_sdk_errors15.InvalidOperation(
        "BloomFilter.join",
        "different length values",
        { this: this, other }
      );
    }
    throw new import_sdk_errors15.InvalidOperation("BloomFilter.join", "different k values", {
      this: this,
      other
    });
  }
  /**
   * Creates a new instance of BloomFilterBuilder and adds the specified keys to it.
   * * Call {@link BloomFilterBuilder.add} to add more keys.
   * * Call {@link BloomFilterBuilder.build} to create a new Bloom filter once
   *
   * @param {...(Hex[] | Uint8Array[])} keys - The keys to be added to the BloomFilterBuilder.
   *
   * @returns {BloomFilterBuilder} - A new instance of BloomFilterBuilder with the specified keys added.
   *
   * @remarks Security auditable method, depends on
   * * {@link BloomFilterBuilder.add}.
   */
  static of(...keys) {
    const builder = new BloomFilterBuilder();
    builder.add(...keys);
    return builder;
  }
};
var BloomFilterBuilder = class _BloomFilterBuilder {
  /**
   * The default value number of hash functions used to create {@link BloomFilter} instances.
   */
  static DEFAULT_K = 5;
  /**
   * Map each element of the keys as likely part of the data structure of the Bloom filter to build.
   * Each key is mapped in `m` bits using `k` hash functions.
   *
   * @see {hash}
   */
  hashMap = /* @__PURE__ */ new Map();
  /**
   * Adds one or more keys to the Bloom filter to create.
   *
   * @param {Hex[] | Uint8Array[]} keys - The keys to be added to Bloom filter to create.
   *
   * @return {this} - Returns this {@link BloomFilterBuilder} instance, the {@link this.hashMap} is updated to
   * map the keys presence in the filter data structure.
   *
   * @remarks Security auditable method, depends on
   * * {@link hash}.
   */
  add(...keys) {
    for (const key of keys) {
      this.hashMap.set(hash(key instanceof Hex ? key.bytes : key), true);
    }
    return this;
  }
  /**
   * Builds a Bloom filter with the specified parameters and returns it.
   *
   * @param k - The number of hash functions to use in the Bloom filter.  to BloomFilterBuilder.DEFAULT_K.
   * @param m - The number of bits per key in the Bloom filter. Defaults to the value computed by BloomFilter.computeBestBitsPerKey(k).
   *
   * @return The built Bloom filter.
   */
  build(k = _BloomFilterBuilder.DEFAULT_K, m = BloomFilter.computeBestBitsPerKey(k)) {
    let nBytes = Math.floor((this.hashMap.size * m + 7) / 8);
    nBytes = nBytes < 8 ? 8 : nBytes;
    const bits = new Uint8Array(nBytes);
    const nBits = nBytes * 8;
    for (const hash2 of this.hashMap.keys()) {
      distribute(hash2, k, nBits, (index, bit) => {
        bits[index] |= bit;
        return true;
      });
    }
    return new BloomFilter(bits, k);
  }
};
var UINT32_LIMIT = 2 ** 32;
function addAndWrapAsUInt32(a, b) {
  return (a + b) % UINT32_LIMIT;
}
function distribute(hash2, k, m, collision) {
  const delta = (hash2 >>> 17 | hash2 << 15) >>> 0;
  for (let i = 0; i < k; i++) {
    const bitPos = hash2 % m;
    if (!collision(Math.floor(bitPos / 8), 1 << bitPos % 8)) {
      return false;
    }
    hash2 = addAndWrapAsUInt32(hash2, delta);
  }
  return true;
}
function hash(key) {
  return Number(
    nc_utils4.bytesToNumberBE(Blake2b256.of(key).bytes.slice(0, 4))
  );
}

// src/vcdm/FPN.ts
var import_sdk_errors16 = require("@vechain/sdk-errors");
var FPN = class _FPN {
  /**
   * The default number of decimal places to use for fixed-point math.
   *
   * @see
   * [bignumber.js DECIMAL_PLACES](https://mikemcl.github.io/bignumber.js/#decimal-places)
   *
   * @constant {bigint}
   */
  static DEFAULT_FRACTIONAL_DECIMALS = 20n;
  /**
   * Not a Number.
   *
   * @remarks {@link fd} and {@link sv} not meaningful.
   *
   * @see [Number.NaN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN)
   *
   */
  static NaN = new _FPN(0n, 0n, NaN);
  /**
   * The negative Infinity value.
   *
   * @remarks {@link fd} and {@link sv} not meaningful.
   *
   * @see [Number.NEGATIVE_INFINITY](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NEGATIVE_INFINITY)
   */
  static NEGATIVE_INFINITY = new _FPN(
    0n,
    0n,
    Number.NEGATIVE_INFINITY
  );
  /**
   * The positive Infinite value.
   *
   * @remarks {@link fd} and {@link sv} not meaningful.
   *
   * @see [Number.POSITIVE_INFINITY](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY)
   */
  static POSITIVE_INFINITY = new _FPN(
    0n,
    0n,
    Number.POSITIVE_INFINITY
  );
  /**
   * Regular expression pattern for matching integers expressed as base 10 strings.
   *
   * @type {RegExp}
   * @constant
   */
  static REGEX_INTEGER = /^[-+]?\d+$/;
  /**
   * Regular expression for matching numeric values expressed as base 10 strings.
   *
   * @constant {RegExp} NUMERIC_REGEX
   */
  static REGEX_NUMBER = /(^[-+]?\d+(\.\d+)?)$|(^[-+]?\.\d+)$/;
  /**
   * Regular expression pattern for matching natural numbers expressed as base 10 strings.
   *
   * @type {RegExp}
   * @constant
   */
  static REGEX_NATURAL = /^\d+$/;
  /**
   * Represents the zero constant.
   */
  static ZERO = new _FPN(0n, 0n, 0);
  /**
   * Edge Flag denotes the {@link NaN} or {@link NEGATIVE_INFINITY} or {@link POSITIVE_INFINITY} value.
   *
   * @remarks If `ef` is not zero, {@link fd} and {@link sv} are not meaningful.
   *
   * @private
   */
  ef;
  /**
   * Fractional Digits or decimal places.
   * @private
   */
  fd;
  /**
   * Scaled Value = value * 10 ^ {@link fd}.
   * @private
   */
  sv;
  /**
   * Returns the integer part of this FPN value.
   *
   * @return {bigint} the integer part of this FPN value.
   *
   * @throws {InvalidOperation} If the value is not finite.
   */
  get bi() {
    if (this.isFinite()) {
      return this.sv / 10n ** this.fd;
    }
    throw new import_sdk_errors16.InvalidOperation(
      "FPN.bi",
      "not finite value cannot cast to big integer",
      { this: this.toString() }
    );
  }
  /**
   * Returns the array of bytes representing the *Normalization Form Canonical Composition*
   * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence)
   * of this value expressed in decimal base.
   */
  get bytes() {
    return Txt.of(this.toString()).bytes;
  }
  /**
   * Return this value approximated as {@link number}.
   */
  get n() {
    if (this.isNaN()) return Number.NaN;
    if (this.isNegativeInfinite()) return Number.NEGATIVE_INFINITY;
    if (this.isPositiveInfinite()) return Number.POSITIVE_INFINITY;
    if (this.isZero()) return 0;
    return Number(this.sv) * 10 ** -Number(this.fd);
  }
  /**
   * Returns the new Fixed-Point Number (FPN) instance having
   *
   * @param {bigint} fd - Number of Fractional Digits (or decimal places).
   * @param {bigint} sv - Scaled Value.
   * @param {number} [ef=0] - Edge Flag.
   */
  constructor(fd, sv, ef = 0) {
    this.fd = fd;
    this.ef = ef;
    this.sv = sv;
  }
  /**
   * Returns a FPN whose value is the absolute value, i.e. the magnitude, of the value of this FPN.
   *
   * @return {FPN} the absolute value of this FPN.
   *
   * @see [bignumber.js absoluteValue](https://mikemcl.github.io/bignumber.js/#abs)
   */
  abs() {
    return new _FPN(this.fd, this.sv < 0n ? -this.sv : this.sv);
  }
  /**
   * Compares this instance with `that` FPN instance.
   * * Returns 0 if this is equal to `that` FPN, including infinite with equal sign;
   * * Returns -1, if this is -Infinite or less than `that` FPN;,
   * * Returns 1 if this is +Infinite or greater than `that` FPN.
   *
   * @param {FPN} that - The instance to compare with this instance.
   *
   * @return {number} Returns -1, 0, or 1 if this instance is less than, equal to, or greater
   * than the specified instance, respectively.
   *
   * @throw InvalidOperation If this or `that` FPN is {@link NaN}.
   *
   * @see [bignumber.js comparedTo](https://mikemcl.github.io/bignumber.js/#cmp)
   */
  compareTo(that) {
    if (this.isNaN() || that.isNaN())
      throw new import_sdk_errors16.InvalidOperation("FPN.compareTo", "compare between NaN", {
        this: `${this}`,
        that: `${that}`
      });
    if (this.isNegativeInfinite())
      return that.isNegativeInfinite() ? 0 : -1;
    if (this.isPositiveInfinite()) return that.isPositiveInfinite() ? 0 : 1;
    if (that.isNegativeInfinite()) return 1;
    if (that.isPositiveInfinite()) return -1;
    const fd = this.fd > that.fd ? this.fd : that.fd;
    const delta = this.dp(fd).sv - that.dp(fd).sv;
    return delta < 0n ? -1 : delta === 0n ? 0 : 1;
  }
  /**
   * Compares this instance with `that` FPN instance.
   * * **Returns `null` if either instance is NaN;**
   * * Returns 0 if this is equal to `that` FPN, including infinite with equal sign;
   * * Returns -1, if this is -Infinite or less than `that` FPN;,
   * * Returns 1 if this is +Infinite or greater than `that` FPN.
   *
   * @param {FPN} that - The instance to compare with this instance.
   *
   * @return {null | number} A null if either instance is NaN;
   * -1, 0, or 1 if this instance is less than, equal to, or greater
   * than the specified instance, respectively.
   *
   * @remarks This method uses internally {@link compareTo} wrapping the {@link InvalidOperation} exception
   * when comparing between {@link NaN} values to behave according the
   * [[bignumber.js comparedTo](https://mikemcl.github.io/bignumber.js/#cmp)] rules.
   */
  comparedTo(that) {
    try {
      return this.compareTo(that);
    } catch (e) {
      return null;
    }
  }
  /**
   * Returns a FPN whose value is the value of this FPN divided by `that` FPN.
   *
   * Limit cases
   * * 0 / 0 = NaN
   * * NaN / ±n = NaN
   * * +n / NaN = NaN
   * * +n / ±Infinity = 0
   * * -n / 0 = -Infinity
   * * +n / 0 = +Infinity
   *
   * @param {FPN} that - The fixed-point number to divide by.
   *
   * @return {FPN} The result of the division.
   *
   * @remarks The precision is the greater of the precision of the two operands.
   *
   * @see [bignumber.js dividedBy](https://mikemcl.github.io/bignumber.js/#div)
   */
  div(that) {
    if (this.isNaN() || that.isNaN()) return _FPN.NaN;
    if (that.isInfinite()) return _FPN.ZERO;
    if (that.isZero())
      return this.isZero() ? _FPN.NaN : this.isNegative() ? _FPN.NEGATIVE_INFINITY : _FPN.POSITIVE_INFINITY;
    const fd = this.fd > that.fd ? this.fd : that.fd;
    return new _FPN(fd, _FPN.div(fd, this.dp(fd).sv, that.dp(fd).sv));
  }
  /**
   * Divides the given dividend by the given divisor, adjusted by a factor based on fd.
   *
   * @param {bigint} fd - The factor determining the power of 10 to apply to the dividend.
   * @param {bigint} dividend - The number to be divided.
   * @param {bigint} divisor - The number by which to divide the dividend.
   *
   * @return {bigint} - The result of the division, adjusted by the given factor fd.
   */
  static div(fd, dividend, divisor) {
    return 10n ** fd * dividend / divisor;
  }
  /**
   * Adjusts the precision of the floating-point number by the specified
   * number of decimal places.
   *
   * @param {bigint | number} decimalPlaces - The number of decimal places to adjust to.
   *
   * @return {FPN} A new FPN instance with the adjusted precision.
   */
  dp(decimalPlaces) {
    const fp = BigInt(decimalPlaces);
    const dd = fp - this.fd;
    if (dd < 0) {
      return new _FPN(fp, this.sv / 10n ** -dd);
    } else {
      return new _FPN(fp, this.sv * 10n ** dd);
    }
  }
  /**
   * Returns `true `if the value of thisFPN is equal to the value of `that` FPN, otherwise returns `false`.
   *
   * As with JavaScript, `NaN` does not equal `NaN`.
   *
   * @param {FPN} that - The FPN to compare against.
   *
   * @return {boolean} `true` if the FPN numbers are equal, otherwise `false`.
   *
   * @remarks This method uses {@link comparedTo} internally.
   *
   * @see [bigbumber.js isEqualTo](https://mikemcl.github.io/bignumber.js/#eq)
   */
  eq(that) {
    return this.comparedTo(that) === 0;
  }
  /**
   * Returns `true` if the value of this FPN is greater than `that` FPN`, otherwise returns `false`.
   *
   * @param {FPN} that - The FPN to compare against.
   *
   * @return {boolean} `true` if this FPN is greater than `that` FPN, otherwise `false`.
   *
   * @remarks This method uses {@link comparedTo} internally.
   *
   * @see [bignummber.js isGreaterThan](https://mikemcl.github.io/bignumber.js/#gt)
   */
  gt(that) {
    const cmp = this.comparedTo(that);
    return cmp !== null && cmp > 0;
  }
  /**
   * Returns `true` if the value of this FPN is greater or equal than `that` FPN`, otherwise returns `false`.
   *
   * @param {FPN} that - The FPN to compare against.
   *
   * @return {boolean} `true` if this FPN is greater or equal than `that` FPN, otherwise `false`.
   *
   * @remarks This method uses {@link comparedTo} internally.
   *
   * @see [bignumber.js isGreaterThanOrEqualTo](https://mikemcl.github.io/bignumber.js/#gte)
   */
  gte(that) {
    const cmp = this.comparedTo(that);
    return cmp !== null && cmp >= 0;
  }
  /**
   * Returns a fixed-point number whose value is the integer part of dividing the value of this fixed-point number
   * by `that` fixed point number.
   *
   * Limit cases
   * * 0 / 0 = NaN
   * * NaN / ±n = NaN
   * * +n / NaN = NaN
   * * +n / ±Infinite = 0
   * * -n / 0 = -Infinite
   * * +n / 0 = +Infinite
   *
   * @param {FPN} that - The fixed-point number to divide by.
   *
   * @return {FPN} The result of the division.
   *
   * @remarks The precision is the greater of the precision of the two operands.
   *
   * @see [bignumber.js dividedToIntegerBy](https://mikemcl.github.io/bignumber.js/#divInt)
   */
  idiv(that) {
    if (this.isNaN() || that.isNaN()) return _FPN.NaN;
    if (that.isInfinite()) return _FPN.ZERO;
    if (that.isZero())
      return this.isZero() ? _FPN.NaN : this.isNegative() ? _FPN.NEGATIVE_INFINITY : _FPN.POSITIVE_INFINITY;
    const fd = this.fd > that.fd ? this.fd : that.fd;
    return new _FPN(fd, _FPN.idiv(fd, this.dp(fd).sv, that.dp(fd).sv));
  }
  /**
   * Performs integer division on two big integers and scales the result by a factor of 10 raised to the power of fd.
   *
   * @param {bigint} fd - The power to which 10 is raised to scale the result.
   * @param {bigint} dividend - The number to be divided.
   * @param {bigint} divisor - The number by which dividend is divided.
   *
   * @return {bigint} - The scaled result of the integer division.
   */
  static idiv(fd, dividend, divisor) {
    return dividend / divisor * 10n ** fd;
  }
  /**
   * Returns `true `if the value of thisFPN is equal to the value of `that` FPN, otherwise returns `false`.
   *
   * As with JavaScript, `NaN` does not equal `NaN`.
   *
   * @param {FPN} that - The FPN to compare against.
   *
   * @return {boolean} `true` if the FPN numbers are equal, otherwise `false`.
   *
   * @remarks This method uses {@link eq} internally.
   */
  isEqual(that) {
    return this.eq(that);
  }
  /**
   * Returns `true` if the value of this FPN is a finite number, otherwise returns `false`.
   *
   * The only possible non-finite values of a FPN are {@link NaN}, {@link NEGATIVE_INFINITY} and {@link POSITIVE_INFINITY}.
   *
   * @return `true` if the value of this FPN is a finite number, otherwise returns `false`.
   *
   * @see [bignumber.js isFinite](https://mikemcl.github.io/bignumber.js/#isF)
   */
  isFinite() {
    return this.ef === 0;
  }
  /**
   * Return `true` if the value of this FPN is {@link NEGATIVE_INFINITY} and {@link POSITIVE_INFINITY},
   * otherwise returns false.
   *
   * @return true` if the value of this FPN is {@link NEGATIVE_INFINITY} and {@link POSITIVE_INFINITY},
   */
  isInfinite() {
    return this.isNegativeInfinite() || this.isPositiveInfinite();
  }
  /**
   * Returns `true` if the value of this FPN is an integer,
   * otherwise returns `false`.
   *
   * @return `true` if the value of this FPN is an integer.
   *
   * @see [bignumber.js isInteger](https://mikemcl.github.io/bignumber.js/#isInt)
   */
  isInteger() {
    if (this.isFinite()) {
      return this.sv % 10n ** this.fd === 0n;
    }
    return false;
  }
  /**
   * Checks if a given string expression is an integer in base 10 notation,
   * considering `-` for negative and `+` optional for positive values.
   *
   * @param {string} exp - The string expression to be tested.
   *
   * @return {boolean} `true` if the expression is an integer,
   * `false` otherwise.
   */
  static isIntegerExpression(exp) {
    return this.REGEX_INTEGER.test(exp);
  }
  /**
   *  Returns `true` if the value of this FPN is `NaN`, otherwise returns `false`.
   *
   *  @return `true` if the value of this FPN is `NaN`, otherwise returns `false`.
   *
   *  @see [bignumber.js isNaN](https://mikemcl.github.io/bignumber.js/#isNaN)
   */
  isNaN() {
    return Number.isNaN(this.ef);
  }
  /**
   * Checks if a given string expression is a natural (unsigned positive integer)
   * number in base 10 notation.
   *
   * @param {string} exp - The string expression to be tested.
   *
   * @return {boolean} `true` if the expression is a natural number,
   * `false` otherwise.
   */
  static isNaturalExpression(exp) {
    return this.REGEX_NATURAL.test(exp);
  }
  /**
   * Returns `true` if the sign of this FPN is negative, otherwise returns `false`.
   *
   * @return `true` if the sign of this FPN is negative, otherwise returns `false`.
   *
   * @see [bignumber.js isNegative](https://mikemcl.github.io/bignumber.js/#isNeg)
   */
  isNegative() {
    return this.isFinite() && this.sv < 0n || this.isNegativeInfinite();
  }
  /**
   * Returns `true` if this FPN value is {@link NEGATIVE_INFINITY}, otherwise returns `false`.
   */
  isNegativeInfinite() {
    return this.ef === Number.NEGATIVE_INFINITY;
  }
  /**
   * Checks if a given string expression is a number in base 10 notation,
   * considering `-` for negative and `+` optional for positive values.
   *
   * The method returns `true` for the following cases.
   * - Whole numbers:
   *   - Positive whole numbers, optionally signed: 1, +2, 3, ...
   *   - Negative whole numbers: -1, -2, -3, ...
   * - Decimal numbers:
   *   - Positive decimal numbers, optionally signed: 1.0, +2.5, 3.14, ...
   *   - Negative decimal numbers: -1.0, -2.5, -3.14, ...
   *   - Decimal numbers without whole part:
   *     - Positive decimal numbers, optionally signed: .1, +.5, .75, ...
   *     - Negative decimal numbers: -.1, -.5, -.75, ...
   *
   * @param exp - The string expression to be checked.
   *
   * @return `true` is `exp` represents a number, otherwise `false`.
   */
  static isNumberExpression(exp) {
    return _FPN.REGEX_NUMBER.test(exp);
  }
  /**
   * Returns `true` if the sign of this FPN is positive, otherwise returns `false`.
   *
   * @return `true` if the sign of this FPN is positive, otherwise returns `false`.
   *
   * @see [bignumber.js isPositive](https://mikemcl.github.io/bignumber.js/#isPos)
   */
  isPositive() {
    return this.isFinite() && this.sv >= 0n || this.isPositiveInfinite();
  }
  /**
   * Returns `true` if this FPN value is {@link POSITIVE_INFINITY}, otherwise returns `false`.
   *
   * @return `true` if this FPN value is {@link POSITIVE_INFINITY}, otherwise returns `false`.
   */
  isPositiveInfinite() {
    return this.ef === Number.POSITIVE_INFINITY;
  }
  /**
   * Checks if a given string expression is an unsigned positive integer.
   *
   * @param {string} exp - The string expression to be tested.
   *
   * @return {boolean} True if the expression is an unsigned positive integer,
   * false otherwise.
   */
  static isUnsignedIntegerExpression(exp) {
    return this.REGEX_NATURAL.test(exp);
  }
  /**
   * Returns `true` if the value of this FPN is zero or minus zero, otherwise returns `false`.
   *
   * @return `true` if the value of this FPN is zero or minus zero, otherwise returns `false`.
   *
   * [see bignumber.js isZero](https://mikemcl.github.io/bignumber.js/#isZ)
   */
  isZero() {
    return this.isFinite() && this.sv === 0n;
  }
  /**
   * Returns `true` if the value of this FPN is less than the value of `that` FPN, otherwise returns `false`.
   *
   * @param {FPN} that - The FPN to compare against.
   *
   * @return {boolean} `true` if the value of this FPN is less than the value of `that` FPN, otherwise returns `false`.
   *
   * @remarks This method uses {@link comparedTo} internally.
   *
   * @see [bignumber.js isLessThan](https://mikemcl.github.io/bignumber.js/#lt)
   */
  lt(that) {
    const cmp = this.comparedTo(that);
    return cmp !== null && cmp < 0;
  }
  /**
   * Returns `true` if the value of this FPN is less than or equal to the value of `that` FPN,
   * otherwise returns `false`.
   *
   * @param {FPN} that true` if the value of this FPN is less than or equal to the value of `that` FPN,
   * otherwise returns `false`.
   *
   * @return {boolean} `true` if the value of this FPN is less than or equal to the value of `that` FPN,
   * otherwise returns `false`.
   *
   * @remarks This method uses {@link comparedTo} internally.
   *
   * @see [bignumber.js isLessThanOrEqualTo](https://mikemcl.github.io/bignumber.js/#lte)
   */
  lte(that) {
    const cmp = this.comparedTo(that);
    return cmp !== null && cmp <= 0;
  }
  /**
   * Returns a FPN whose value is the value of this FPN minus `that` FPN.
   *
   * Limit cases
   * * NaN - ±n = NaN
   * * ±n - NaN = NaN
   * * -Infinity - -Infinity = NaN
   * * -Infinity - +n = -Infinity
   * * +Infinity - +Infinity = NaN
   * * +Infinity - +n = +Infinity
   *
   * @param {FPN} that The fixed-point number to subtract.
   *
   * @return {FPN} The result of the subtraction. The return value is always exact and unrounded.
   *
   * @remarks The precision is the greater of the precision of the two operands.
   *
   * @see [bignumber.js minus](https://mikemcl.github.io/bignumber.js/#minus)
   */
  minus(that) {
    if (this.isNaN() || that.isNaN()) return _FPN.NaN;
    if (this.isNegativeInfinite())
      return that.isNegativeInfinite() ? _FPN.NaN : _FPN.NEGATIVE_INFINITY;
    if (this.isPositiveInfinite())
      return that.isPositiveInfinite() ? _FPN.NaN : _FPN.POSITIVE_INFINITY;
    const fd = this.fd > that.fd ? this.fd : that.fd;
    return new _FPN(fd, this.dp(fd).sv - that.dp(fd).sv);
  }
  /**
   * Returns a FPN whose value is the value of this FPN modulo `that` FPN,
   * i.e. the integer remainder of dividing this FPN by `that`.
   *
   * Limit cases
   * * NaN % ±n = NaN
   * * ±n % NaN = NaN
   * * ±Infinity % n = NaN
   * * n % ±Infinity = NaN
   *
   * @param that {FPN} The fixed-point number to divide by.
   *
   * @return {FPN} the integer remainder of dividing this FPN by `that`.
   *
   * @remarks The precision is the greater of the precision of the two operands.
   *
   * @see [bignumber.js modulo](https://mikemcl.github.io/bignumber.js/#mod)
   */
  modulo(that) {
    if (this.isNaN() || that.isNaN()) return _FPN.NaN;
    if (this.isInfinite() || that.isInfinite()) return _FPN.NaN;
    if (that.isZero()) return _FPN.NaN;
    const fd = this.fd > that.fd ? this.fd : that.fd;
    let modulo = this.abs().dp(fd).sv;
    const divisor = that.abs().dp(fd).sv;
    while (modulo >= divisor) {
      modulo -= divisor;
    }
    return new _FPN(fd, modulo);
  }
  /**
   * Multiplies two big integer values and divides by a factor of ten raised to a specified power.
   *
   * @param {bigint} multiplicand - The first number to be multiplied.
   * @param {bigint} multiplicator - The second number to be multiplied.
   * @param {bigint} fd - The power of ten by which the product is to be divided.
   *
   * @return {bigint} The result of the multiplication divided by ten raised to the specified power.
   */
  static mul(multiplicand, multiplicator, fd) {
    return multiplicand * multiplicator / 10n ** fd;
  }
  static of(exp, decimalPlaces = this.DEFAULT_FRACTIONAL_DECIMALS) {
    if (Number.isNaN(exp)) return new _FPN(decimalPlaces, 0n, Number.NaN);
    if (exp === Number.NEGATIVE_INFINITY)
      return new _FPN(decimalPlaces, -1n, Number.NEGATIVE_INFINITY);
    if (exp === Number.POSITIVE_INFINITY)
      return new _FPN(decimalPlaces, 1n, Number.POSITIVE_INFINITY);
    return new _FPN(
      decimalPlaces,
      this.txtToSV(exp.toString(), decimalPlaces)
    );
  }
  /**
   * Returns a FPN whose value is the value of this FPN plus `that` FPN.
   *
   * Limit cases
   * * NaN + ±n = NaN
   * * ±n + NaN = NaN
   * * -Infinity + -Infinity = -Infinity
   * * -Infinity + +Infinity = NaN
   * * +Infinity + -Infinity = NaN
   * * +Infinity + +Infinity = +Infinity
   *
   * @param {FPN} that - The fixed-point number to add to the current number.
   *
   * @return {FPN} The result of the addition. The return value is always exact and unrounded.
   *
   * @remarks The precision is the greater of the precision of the two operands.
   *
   * @see [bignumber.js plus](https://mikemcl.github.io/bignumber.js/#plus)
   */
  plus(that) {
    if (this.isNaN() || that.isNaN()) return _FPN.NaN;
    if (this.isNegativeInfinite())
      return that.isPositiveInfinite() ? _FPN.NaN : _FPN.NEGATIVE_INFINITY;
    if (this.isPositiveInfinite())
      return that.isNegativeInfinite() ? _FPN.NaN : _FPN.POSITIVE_INFINITY;
    const fd = this.fd > that.fd ? this.fd : that.fd;
    return new _FPN(fd, this.dp(fd).sv + that.dp(fd).sv);
  }
  /**
   * Returns a FPN whose value is the value of this FPN raised to the power of `that` FPN.
   *
   * Limit cases
   * * NaN ^ e = NaN
   * * b ^ NaN = NaN
   * * b ^ -Infinite = 0
   * * b ^ 0 = 1
   * * b ^ +Infinite = +Infinite
   * * ±Infinite ^ -e = 0
   * * ±Infinite ^ +e = +Infinite
   *
   * @param {FPN} that - The exponent as a fixed-point number.
   *                     It can be negative, it can be not an integer value
   *                     ([bignumber.js pow](https://mikemcl.github.io/bignumber.js/#pow)
   *                     doesn't support not integer exponents).
   * @return {FPN} - The result of raising this fixed-point number to the power of the given exponent.
   *
   * @remarks The precision is the greater of the precision of the two operands.
   * @remarks In fixed-precision math, the comparisons between powers of operands having different fractional
   * precision can lead to differences.
   *
   * @see [bignumber.js exponentiatedBy](https://mikemcl.github.io/bignumber.js/#pow)
   */
  pow(that) {
    if (this.isNaN() || that.isNaN()) return _FPN.NaN;
    if (this.isInfinite())
      return that.isZero() ? _FPN.of(1) : that.isNegative() ? _FPN.ZERO : _FPN.POSITIVE_INFINITY;
    if (that.isNegativeInfinite()) return _FPN.ZERO;
    if (that.isPositiveInfinite()) return _FPN.POSITIVE_INFINITY;
    const fd = this.fd > that.fd ? this.fd : that.fd;
    return new _FPN(fd, _FPN.pow(fd, this.dp(fd).sv, that.dp(fd).sv));
  }
  /**
   * Computes the power of a given base raised to a specified exponent.
   *
   * @param {bigint} fd - The scale factor for decimal precision.
   * @param {bigint} base - The base number to be raised to the power.
   * @param {bigint} exponent - The exponent to which the base should be raised.
   * @return {bigint} - The result of base raised to the power of exponent, scaled by the scale factor.
   */
  static pow(fd, base, exponent) {
    const sf = 10n ** fd;
    if (exponent < 0n) {
      return _FPN.pow(fd, _FPN.div(fd, sf, base), -exponent);
    }
    if (exponent === 0n) {
      return 1n * sf;
    }
    if (exponent === sf) {
      return base;
    }
    return _FPN.pow(fd, this.mul(base, base, fd), exponent - sf);
  }
  /**
   * Computes the square root of a given positive bigint value using a fixed-point iteration method.
   *
   * @param {bigint} value - The positive bigint value for which the square root is to be calculated.
   * @param {bigint} fd - The iteration factor determinant.
   *
   * @return {bigint} The calculated square root of the input bigint value.
   *
   * @throws {RangeError} If the input value is negative.
   */
  static sqr(value, fd) {
    if (value < 0n) {
      throw new RangeError(`Value must be positive`);
    }
    const sf = fd * 10n;
    let iteration = 0;
    let actualResult = value;
    let storedResult = 0n;
    while (actualResult !== storedResult && iteration < sf) {
      storedResult = actualResult;
      actualResult = (actualResult + _FPN.div(fd, value, actualResult)) / 2n;
      iteration++;
    }
    return actualResult;
  }
  /**
   * Returns a FPN whose value is the square root of the value of this FPN
   *
   * Limit cases
   * * √ NaN = NaN
   * * +Infinite = +Infinite
   * * -n = NaN
   *
   * @return {FPN} The square root of the number.
   *
   * @see [bignumber.js sqrt](https://mikemcl.github.io/bignumber.js/#sqrt)
   */
  sqrt() {
    if (this.isNaN()) return _FPN.NaN;
    if (this.isPositiveInfinite()) return _FPN.POSITIVE_INFINITY;
    try {
      return new _FPN(this.fd, _FPN.sqr(this.sv, this.fd));
    } catch (e) {
      return _FPN.NaN;
    }
  }
  /**
   * Returns a FPN whose value is the value of this FPN multiplied by `that` FPN.
   *
   * Limits cases
   * * NaN * n = NaN
   * * n * NaN = NaN
   * * -Infinite * -n = +Infinite
   * * -Infinite * +n = -Infinite
   * * +Infinite * -n = -Infinite
   * * +Infinite * +n = +Infinite
   *
   * @param {FPN} that - The fixed-point number to multiply with this number.
   *
   * @return {FPN} a FPN whose value is the value of this FPN multiplied by `that` FPN.
   *
   * @remarks The precision is the greater of the precision of the two operands.
   *
   * @see [bignumber.js multipliedBy](https://mikemcl.github.io/bignumber.js/#times)
   */
  times(that) {
    if (this.isNaN() || that.isNaN()) return _FPN.NaN;
    if (this.isNegativeInfinite())
      return that.isNegative() ? _FPN.POSITIVE_INFINITY : _FPN.NEGATIVE_INFINITY;
    if (this.isPositiveInfinite())
      return that.isNegative() ? _FPN.NEGATIVE_INFINITY : _FPN.POSITIVE_INFINITY;
    const fd = this.fd > that.fd ? this.fd : that.fd;
    return new _FPN(fd, _FPN.mul(this.dp(fd).sv, that.dp(fd).sv, fd));
  }
  toString(decimalSeparator = ".") {
    if (this.ef === 0) {
      const sign3 = this.sv < 0n ? "-" : "";
      const digits = this.sv < 0n ? (-this.sv).toString() : this.sv.toString();
      const padded = digits.padStart(Number(this.fd), "0");
      const decimals = padded.slice(Number(-this.fd));
      const integers = padded.slice(0, padded.length - decimals.length);
      const integersShow = integers.length < 1 ? "0" : integers;
      const decimalsShow = _FPN.trimEnd(decimals);
      return sign3 + integersShow + (decimalsShow.length > 0 ? decimalSeparator + decimalsShow : "");
    }
    return this.ef.toString();
  }
  static trimEnd(str, sub = "0") {
    if (str.endsWith(sub)) {
      return _FPN.trimEnd(str.substring(0, str.length - sub.length), sub);
    }
    return str;
  }
  static txtToSV(exp, fd, decimalSeparator = ".") {
    const fc = exp.charAt(0);
    let sign3 = 1n;
    if (fc === "-") {
      sign3 = -1n;
      exp = exp.substring(1);
    } else if (fc === "+") {
      exp = exp.substring(1);
    }
    const sf = 10n ** fd;
    const di = exp.lastIndexOf(decimalSeparator);
    if (di < 0) {
      return sign3 * sf * BigInt(exp);
    }
    const ie = exp.substring(0, di);
    const fe = exp.substring(di + 1);
    return sign3 * sf * BigInt(ie) + // Integer part
    sign3 * (sf * BigInt(fe)) / BigInt(10 ** fe.length);
  }
};

// src/vcdm/Mnemonic.ts
var import_bip39 = require("@scure/bip39");
var import_english = require("@scure/bip39/wordlists/english");
var import_sdk_errors17 = require("@vechain/sdk-errors");
var Mnemonic = class _Mnemonic {
  /**
   * A TextEncoder instance used for encoding text to bytes.
   *
   * @type {TextEncoder}
   */
  static ENCODER = new TextEncoder();
  /**
   * Throws an exception because the mnemonic cannot be represented as a big integer.
   * @returns {bigint} The BigInt representation of the mnemonic.
   * @throws {InvalidOperation} The mnemonic cannot be represented as a bigint.
   * @override {@link VeChainDataModel#bi}
   * @remark The conversion to BigInt is not supported for a mnemonic.
   */
  get bi() {
    throw new import_sdk_errors17.InvalidOperation(
      "Mnemonic.bi",
      "There is no big integer representation for a mnemonic.",
      { data: "" }
    );
  }
  /**
   * Generates a mnemonic as encoded bytes.
   *
   * @returns {Uint8Array} The bytes representation of the words with spaces.
   */
  get bytes() {
    return _Mnemonic.ENCODER.encode(_Mnemonic.of().join(" "));
  }
  /**
   * Throws an exception because the mnemonic cannot be represented as a number.
   * @returns {bigint} The number representation of the mnemonic.
   * @throws {InvalidOperation} The mnemonic cannot be represented as a number.
   * @override {@link VeChainDataModel#n}
   * @remark The conversion to number is not supported for a mnemonic.
   */
  get n() {
    throw new import_sdk_errors17.InvalidOperation(
      "Mnemonic.n",
      "There is no number representation for a mnemonic.",
      { data: "" }
    );
  }
  /**
   *
   * @param _that The mnemonic to compare with.
   */
  compareTo(_that) {
    throw new import_sdk_errors17.InvalidOperation(
      "Mnemonic.compareTo",
      "There is no comparison for a mnemonic since it is not stored in memory.",
      { data: "" }
    );
  }
  isEqual(_that) {
    throw new import_sdk_errors17.InvalidOperation(
      "Mnemonic.isEqual",
      "There is no comparison for a mnemonic since it is not stored in memory.",
      { data: "" }
    );
  }
  /**
   * Convert the number of words to the corresponding strength.
   *
   * @param numberOfWords The number of words.
   *
   * @returns {number} The corresponding strength.
   *
   * @throws {InvalidDataType} If the number of words is not valid.
   */
  static wordsNoToStrength(numberOfWords) {
    switch (numberOfWords) {
      case 12:
        return 128;
      case 15:
        return 160;
      case 18:
        return 192;
      case 21:
        return 224;
      case 24:
        return 256;
      default:
        throw new import_sdk_errors17.InvalidDataType(
          "Mnemonic.wordsNoToStrength",
          "not a valid number of words",
          { numberOfWords }
        );
    }
  }
  // Legacy method, probably should be part of a Private Key class (ofMnemonic) #1122
  /**
   * Derives a private key from a given list of
   * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
   * and a derivation path as in the examples.
   *
   * @example `m/0` (default)
   * @example `m/0/2`
   * @example `m/0/2/4/6`
   *
   * @param {string[]} words - The set of words used for mnemonic generation.
   * @param {string} [path='m/0'] - The derivation path from the current node.
   *
   * @returns {Uint8Array} - The derived private key as a Uint8Array.
   *
   * @throws {InvalidHDKey}
   *
   * @remarks Security auditable method, depends on
   * * {@link HDKey}.
   */
  static toPrivateKey(words, path = "m/0") {
    const root = HDKey2.fromMnemonic(words);
    try {
      return root.derive(path).privateKey;
    } catch (error) {
      throw new import_sdk_errors17.InvalidHDKey(
        "mnemonic.derivePrivateKey()",
        "Invalid derivation path given as input.",
        { derivationPath: path },
        error
      );
    }
  }
  /**
   * Generates a
   * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
   * phrase using the specified wordlist size and random generator.
   *
   * @param {WordlistSizeType} wordlistSize The number of words to generate the mnemonic.
   * @param {function} [randomGenerator] The random generator function used to generate the entropy.
   *
   * @returns {Mnemonic} The generated mnemonic.
   *
   * @throws {InvalidDataType} If the number of words is not valid.
   *
   * @remarks Security auditable method, depends on
   * * [entropyToMnemonic](https://github.com/paulmillr/scure-bip39);
   * * [generateMnemonic](https://github.com/paulmillr/scure-bip39);
   * * `randomGenerator` - **Must provide a cryptographic secure source of entropy
   *    else any secure audit certification related with this software is invalid.**
   */
  static of(wordlistSize = 12, randomGenerator) {
    try {
      const strength = _Mnemonic.wordsNoToStrength(wordlistSize);
      if (randomGenerator != null) {
        const numberOfBytes = strength / 8;
        return (0, import_bip39.entropyToMnemonic)(
          randomGenerator(numberOfBytes),
          import_english.wordlist
        ).split(" ");
      }
      return (0, import_bip39.generateMnemonic)(import_english.wordlist, strength).split(" ");
    } catch (error) {
      throw new import_sdk_errors17.InvalidHDKeyMnemonic(
        "Mnemonic.of",
        "error while generating mnemonic",
        { wordlistSize },
        error
      );
    }
  }
  /**
   * Check if the given mnemonic words are valid.
   *
   * @param {string | string[]} words The mnemonic words to check.
   *
   * @returns {boolean} true if the words are valid, false otherwise.
   *
   * @remarks Security auditable method, depends on
   * * [validateMnemonic](https://github.com/paulmillr/scure-bip39).
   */
  static isValid(words) {
    const wordsToValidate = Array.isArray(words) ? words.join(" ") : words;
    return (0, import_bip39.validateMnemonic)(wordsToValidate, import_english.wordlist);
  }
};
var mnemonic = {
  deriveAddress: (words, path = "m/0") => Address.ofMnemonic(words, path).toString(),
  derivePrivateKey: (words, path = "m/0") => Mnemonic.toPrivateKey(words, path),
  generate: (wordlistSize, randomGenerator) => Mnemonic.of(wordlistSize, randomGenerator),
  isValid: (words) => Mnemonic.isValid(words)
};

// src/vcdm/Quantity.ts
var import_sdk_errors18 = require("@vechain/sdk-errors");
var Quantity = class _Quantity extends HexUInt {
  /**
   * Creates a Quantity instance from a bigint or number given expression
   *
   * @param {bigint | number} exp - The value to be expressed as Quantity object:
   * * bigint must be positive;
   * * number must be positive, it is converted to bigint to create the Quantity.
   *
   * @returns {Quantity} - The new Quantity object.
   *
   * @throws {InvalidDataType} - If the provided expression is not a positive integer value.
   */
  static of(exp) {
    try {
      const huint = HexUInt.of(exp);
      let cue = 0;
      while (cue < huint.digits.length && huint.digits.at(cue) === "0") {
        cue++;
      }
      return new _Quantity(
        huint.sign,
        cue === huint.digits.length ? "0" : huint.digits.slice(cue)
      );
    } catch (e) {
      throw new import_sdk_errors18.InvalidDataType(
        "Quantity.of",
        "not a Quantity expression",
        { exp: `${exp}` },
        // Needed to serialize bigint values.
        e
      );
    }
  }
};

// src/vcdm/Revision.ts
var import_sdk_errors19 = require("@vechain/sdk-errors");
var Revision = class _Revision extends Txt {
  /**
   * Regular expression pattern for revision strings.
   * Revision strings can be one of the following:
   * - "best": indicating the best revision
   * - "finalized": indicating a finalized revision
   * - A positive numeric string indicating a specific revision
   *
   * @type {RegExp}
   */
  static REGEX_DECIMAL_REVISION = /^(best|finalized|\d+)$/;
  /**
   * Determines if the given value is valid.
   * This is true if the given value is
   * - "best" string or {@link Txt}: indicating the best revision;
   * - "finalized" string or {@link Txt}: indicating a finalized revision;
   * - a positive number;
   * - a positive numeric decimal or `0x` prefixed hexadecimal string indicating a specific revision,
   *
   * @param {bigint | number | string | Hex | Txt} value - The value to be validated.
   * @returns {boolean} - Returns `true` if the value is valid, `false` otherwise.
   */
  static isValid(value) {
    if (typeof value === "number") {
      return Number.isInteger(value) && value >= 0;
    }
    return HexUInt.isValid0x(value) || _Revision.REGEX_DECIMAL_REVISION.test(value);
  }
  /**
   * Creates a new Revision object from the given value.
   *
   * @param {bigint | number | string | Uint8Array | Hex } value - The value to create the Revision from:
   * * {@link Hex} must be positive;
   * * {@link Uint8Array} is decoded as a string: see {@link Txt.of}.
   *
   * @returns {Revision} - The created Revision object.
   *
   *  @throws {InvalidDataType} if the given value is not a valid revision: see {@link isValid}.
   *
   * @remarks The string representation of the revision is always expressed as a number in base 10.
   * @remarks The {@link Uint8Array} value is decoded as a string content: see {@link Txt.of}.
   */
  static of(value) {
    try {
      let txt;
      if (value instanceof Hex) {
        txt = value.bi.toString();
      } else if (value instanceof Uint8Array) {
        txt = Txt.of(value).toString();
      } else {
        txt = `${value}`;
      }
      if (_Revision.isValid(txt)) {
        return new _Revision(txt);
      }
      throw new import_sdk_errors19.InvalidDataType("Revision.of", "not a revision", {
        value: `${value}`
      });
    } catch (e) {
      throw new import_sdk_errors19.InvalidDataType("Revision.of", "not a revision", {
        value: `${value}`,
        e
      });
    }
  }
};
var revisionUtils = {
  isRevisionAccount: (revision) => Revision.isValid(revision),
  isRevisionBlock: (revision) => Revision.isValid(revision)
};

// src/vcdm/ThorId.ts
var import_sdk_errors20 = require("@vechain/sdk-errors");
var ThorId = class _ThorId extends HexUInt {
  /**
   * Number of digits to represent a Thor ID value.
   *
   * @remarks The `0x` prefix is excluded.
   *
   * @type {number}
   */
  static DIGITS = 64;
  /**
   * Constructs a ThorId object with the provided hexadecimal value.
   *
   * @param {HexUInt} huint - The hexadecimal value representing the ThorId.
   */
  constructor(huint) {
    super(Hex.POSITIVE, huint.fit(_ThorId.DIGITS).digits);
  }
  /**
   * Check if the given expression is a valid ThorId.
   *
   * @param {string} exp - The expression to be validated.
   *
   * @return {boolean} Returns true if the expression is a valid ThorId, false otherwise.
   */
  static isValid(exp) {
    return Hex.isValid(exp) && HexUInt.REGEX_HEXUINT_PREFIX.test(exp) ? exp.length === _ThorId.DIGITS + 2 : exp.length === _ThorId.DIGITS;
  }
  /**
   * Determines whether the given string is a valid hex number prefixed with '0x'.
   *
   * @param {string} exp - The hex number to be checked.
   *
   *  @returns {boolean} - True if the hex number is valid, false otherwise.
   */
  static isValid0x(exp) {
    return HexUInt.REGEX_HEXUINT_PREFIX.test(exp) && _ThorId.isValid(exp);
  }
  /**
   * Creates a new ThorId object from the given expression.
   *
   * @param {bigint | number | string | Hex | Uint8Array} exp - The expression to create the ThorId from.
   *     It can be one of the following types:
   *     - bigint: A BigInteger value that represents the ThorId.
   *     - number: A number value that represents the ThorId.
   *     - string: A string value that represents the ThorId.
   *     - HexUInt: A HexUInt object that represents the ThorId.
   *     - Uint8Array: A Uint8Array object that represents the ThorId.
   *
   * @returns {ThorId} - A new ThorId object created from the given expression.
   *
   * @throws {InvalidDataType} If the given expression is not a valid hexadecimal positive integer expression.
   */
  static of(exp) {
    try {
      if (exp instanceof HexUInt) {
        return new _ThorId(exp);
      }
      return new _ThorId(HexUInt.of(exp));
    } catch (e) {
      throw new import_sdk_errors20.InvalidDataType(
        "ThorId.of",
        "not a ThorId expression",
        { exp: `${exp}` },
        // Needed to serialize bigint values.
        e
      );
    }
  }
};

// src/certificate/certificate.ts
function encode2(cert) {
  return Txt.of(
    // The following `fastJsonStableStringify` strips blank chars and serialize alphabetical sorted properties.
    (0, import_fast_json_stable_stringify.default)({
      purpose: cert.purpose,
      payload: {
        type: cert.payload.type,
        content: cert.payload.content
      },
      domain: cert.domain,
      timestamp: cert.timestamp,
      signer: cert.signer.toLowerCase()
    })
  ).bytes;
}
function sign(cert, privateKey) {
  return {
    ...cert,
    signature: Hex.of(
      Secp256k1.sign(Blake2b256.of(encode2(cert)).bytes, privateKey)
    ).toString()
  };
}
function verify(cert) {
  if (cert.signature === void 0 || cert.signature === null) {
    throw new import_sdk_errors21.CertificateSignature(
      "certificate.verify()",
      "Verification failed: certificate's signature is missing.",
      { cert }
    );
  }
  if (!Hex.isValid0x(cert.signature) || cert.signature.length % 2 !== 0) {
    throw new import_sdk_errors21.CertificateSignature(
      "certificate.verify()",
      "Verification failed: signature format is invalid.",
      { cert }
    );
  }
  const sign3 = Hex.of(cert.signature).bytes;
  const hash2 = Blake2b256.of(encode2(cert)).bytes;
  const signer = Address.ofPublicKey(Secp256k1.recover(hash2, sign3)).toString().toLowerCase();
  if (signer !== cert.signer?.toLowerCase()) {
    throw new import_sdk_errors21.CertificateSignature(
      "certificate.verify()",
      "Verification failed: signature does not correspond to the signer's public key.",
      { cert }
    );
  }
}
var certificate = { encode: encode2, sign, verify };

// src/utils/const/abi.ts
var ERC20_ABI = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "allowance", type: "uint256" },
      { internalType: "uint256", name: "needed", type: "uint256" }
    ],
    name: "ERC20InsufficientAllowance",
    type: "error"
  },
  {
    inputs: [
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "uint256", name: "balance", type: "uint256" },
      { internalType: "uint256", name: "needed", type: "uint256" }
    ],
    name: "ERC20InsufficientBalance",
    type: "error"
  },
  {
    inputs: [
      { internalType: "address", name: "approver", type: "address" }
    ],
    name: "ERC20InvalidApprover",
    type: "error"
  },
  {
    inputs: [
      { internalType: "address", name: "receiver", type: "address" }
    ],
    name: "ERC20InvalidReceiver",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "sender", type: "address" }],
    name: "ERC20InvalidSender",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "spender", type: "address" }],
    name: "ERC20InvalidSpender",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var ERC721_ABI = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "ERC721IncorrectOwner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ERC721InsufficientApproval",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "approver",
        type: "address"
      }
    ],
    name: "ERC721InvalidApprover",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "ERC721InvalidOperator",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "ERC721InvalidOwner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "ERC721InvalidReceiver",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "ERC721InvalidSender",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ERC721NonexistentToken",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "approved",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getApproved",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "mintItem",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ownerOf",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "tokenURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var ERC1155_ABI = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      }
    ],
    name: "TransferBatch",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "TransferSingle",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "value",
        type: "string"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "URI",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "accounts",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      }
    ],
    name: "balanceOfBatch",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeBatchTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "uri",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var VIP180_ABI = ERC20_ABI;
var VIP181_ABI = ERC721_ABI;
var VIP210_ABI = ERC1155_ABI;

// src/utils/const/data.ts
var ZERO_BYTES = (size) => new Uint8Array(size);
var NUMERIC_REGEX = /(^-?\d+(\.\d+)?)$|(^-?\.\d+)$/;

// src/encoding/rlp/rlp.ts
var import_rlp = require("@ethereumjs/rlp");
var import_sdk_errors22 = require("@vechain/sdk-errors");
function encode3(data) {
  const encodedData = import_rlp.RLP.encode(data);
  return Buffer.from(encodedData);
}
function decode2(encodedData) {
  return import_rlp.RLP.decode(encodedData);
}
var Profiler = class {
  /**
   * Creates a new Profiler instance.
   * @param profile - RLP_CODER profile for encoding/decoding structures.
   */
  constructor(profile) {
    this.profile = profile;
  }
  /**
   * Encodes an object following the provided RLP_CODER profile.
   * @param data - Object to be encoded.
   * @returns - Encoded data as a Buffer.
   */
  encodeObject(data) {
    const packedData = _packData(data, this.profile, "");
    return Buffer.from(import_rlp.RLP.encode(packedData));
  }
  /**
   * Decodes an object following the provided RLP_CODER profile.
   * @param encodedData - Data to be decoded.
   * @returns - Decoded data as RLPValueType.
   */
  decodeObject(encodedData) {
    const packedData = import_rlp.RLP.decode(encodedData);
    return _unpackData(packedData, this.profile, "");
  }
};
var _packData = (obj, profile, context) => {
  context = context !== "" ? context + "." + profile.name : profile.name;
  const kind = profile.kind;
  if (kind instanceof RLPProfiles.ScalarKind) {
    return kind.data(obj, context).encode();
  }
  if (Array.isArray(kind)) {
    return kind.map(
      (k) => _packData(obj[k.name], k, context)
    );
  }
  if (!Array.isArray(obj)) {
    throw new import_sdk_errors22.InvalidRLP(
      "_packData()",
      `Validation error: Expected an array in ${context}.`,
      {
        context,
        data: {
          obj,
          profile
        }
      }
    );
  }
  if ("item" in kind && Array.isArray(obj)) {
    const item = kind.item;
    return obj.map(
      (part, i) => _packData(
        part,
        { name: "#" + i, kind: item },
        context
      )
    );
  }
};
var _unpackData = (packed, profile, context) => {
  context = context !== "" ? context + "." + profile.name : profile.name;
  const kind = profile.kind;
  if (kind instanceof RLPProfiles.ScalarKind) {
    if (!Buffer.isBuffer(packed) && !(packed instanceof Uint8Array)) {
      throw new import_sdk_errors22.InvalidRLP(
        "_unpackData()",
        `Unpacking error: Expected data type is Buffer.`,
        {
          context,
          data: {
            packed,
            profile
          }
        }
      );
    }
    if (packed instanceof Uint8Array) packed = Buffer.from(packed);
    return kind.buffer(packed, context).decode();
  }
  if (Array.isArray(kind) && Array.isArray(packed)) {
    const parts = packed;
    if (kind.length !== parts.length) {
      throw new import_sdk_errors22.InvalidRLP(
        "_unpackData()",
        `Unpacking error: Expected ${kind.length} items, but got ${parts.length}.`,
        {
          context,
          data: {
            packed,
            profile
          }
        }
      );
    }
    return kind.reduce(
      (obj, profile2, index) => {
        obj[profile2.name] = _unpackData(parts[index], profile2, context);
        return obj;
      },
      {}
    );
  }
  if (!Array.isArray(packed)) {
    throw new import_sdk_errors22.InvalidRLP(
      "_unpackData()",
      `Validation error: Expected an array in ${context}.`,
      {
        context,
        data: {
          packed,
          profile
        }
      }
    );
  }
  if ("item" in kind && Array.isArray(packed)) {
    const item = kind.item;
    return packed.map(
      (part, index) => _unpackData(part, { name: "#" + index, kind: item }, context)
    );
  }
};
var RLPBase = { encode: encode3, decode: decode2, Profiler };

// src/encoding/rlp/kind/scalarkind.abstract.ts
var ScalarKind = class {
};

// src/encoding/rlp/kind/bufferkind.ts
var import_sdk_errors23 = require("@vechain/sdk-errors");
var BufferKind = class extends ScalarKind {
  /**
   * Encodes the input data into buffer format.
   *
   * @param data - The data to encode, expected to be of buffer type.
   * @param context - Descriptive context for error messages
   * @returns DataOutput object with an encode function.
   * @throws {InvalidRLP}
   */
  data(data, context) {
    if (!Buffer.isBuffer(data))
      throw new import_sdk_errors23.InvalidRLP(
        "BufferKind.data()",
        `Validation error: Expected a Buffer type in ${context}.`,
        {
          context,
          data: {
            data
          }
        }
      );
    return {
      encode: () => data
      // Data is already a Buffer, so return as-is.
    };
  }
  /**
   * Decodes the input buffer.
   *
   * @param buffer - The buffer to decode, expected to be of buffer type.
   * @param context - Descriptive context for error messages, usually representing the caller's identity.
   * @returns BufferOutput object with a decode function.
   * @throws {InvalidRLP}
   */
  buffer(buffer, context) {
    if (!Buffer.isBuffer(buffer))
      throw new import_sdk_errors23.InvalidRLP(
        "BufferKind.buffer()",
        `Validation error: Expected a Buffer type in ${context}.`,
        {
          context,
          data: {
            buffer
          }
        }
      );
    return {
      decode: () => buffer
      // Buffer is already in the correct format, so return as-is.
    };
  }
};

// src/encoding/rlp/helpers/numerickind.ts
var import_sdk_errors24 = require("@vechain/sdk-errors");
var validateNumericKindData = (data, context) => {
  if (typeof data !== "number" && typeof data !== "string") {
    throw new import_sdk_errors24.InvalidRLP(
      "validateNumericKindData()",
      `Validation error: Input in ${context} must be a string or number.`,
      {
        context,
        data: {
          data
        }
      }
    );
  }
  if (typeof data === "number") {
    _validateNumericKindNumber(data, context);
  } else if (typeof data === "string") {
    _validateNumericKindString(data, context);
  }
  return BigInt(data);
};
var _validateNumericKindNumber = (num, context) => {
  if (!Number.isSafeInteger(num) || num < 0) {
    throw new import_sdk_errors24.InvalidRLP(
      "_validateNumericKindNumber()",
      `Validation error: Number in ${context} must be a safe and non-negative integer.`,
      {
        context,
        data: {
          num
        }
      }
    );
  }
};
var _validateNumericKindString = (str, context) => {
  const isHexUInt = HexUInt.isValid0x(str);
  const isDecimal = FPN.isNaturalExpression(str);
  if (!isHexUInt && !isDecimal) {
    throw new import_sdk_errors24.InvalidRLP(
      "_validateNumericKindString()",
      `Validation error: String in ${context} must represent a non-negative integer in hex or decimal format.`,
      {
        context,
        data: {
          str
        }
      }
    );
  }
  if (isHexUInt && str.length <= 2) {
    throw new import_sdk_errors24.InvalidRLP(
      "_validateNumericKindString()",
      `Validation error: Hex string number in ${context} must be of valid length.`,
      {
        context,
        data: {
          str
        }
      }
    );
  }
};
var assertValidNumericKindBuffer = (buf, context, maxBytes) => {
  if (maxBytes !== void 0 && buf.length > maxBytes) {
    throw new import_sdk_errors24.InvalidRLP(
      "assertValidNumericKindBuffer()",
      `Validation error: Buffer in ${context} must be less than ${maxBytes} bytes.`,
      {
        context,
        data: {
          buf,
          maxBytes
        }
      }
    );
  }
  if (buf[0] === 0) {
    throw new import_sdk_errors24.InvalidRLP(
      "assertValidNumericKindBuffer()",
      `Validation error: Buffer in ${context} must represent a canonical integer (no leading zeros).`,
      {
        context,
        data: {
          buf,
          maxBytes
        }
      }
    );
  }
};
var encodeBigIntToBuffer = (bi, maxBytes, context) => {
  if (bi === 0n) return Buffer.alloc(0);
  const hex = Hex.of(bi).digits;
  if (maxBytes !== void 0 && hex.length > maxBytes * 2) {
    throw new import_sdk_errors24.InvalidRLP(
      "encodeBigIntToBuffer()",
      `Validation error: Encoded number in ${context} must fit within ${maxBytes} bytes.`,
      {
        context,
        data: {
          hex,
          maxBytes
        }
      }
    );
  }
  return Buffer.from(hex, "hex");
};
var decodeBufferToNumberOrHex = (buffer) => {
  if (buffer.length === 0) return 0;
  const bi = Hex.of(buffer).bi;
  const num = Number(bi);
  return Number.isSafeInteger(num) ? num : "0x" + bi.toString(16);
};

// src/encoding/rlp/helpers/hexblobkind.ts
var import_sdk_errors25 = require("@vechain/sdk-errors");
var assertValidHexBlobKindData = (data, context) => {
  if (typeof data !== "string") {
    throw new import_sdk_errors25.InvalidRLP(
      "assertValidHexBlobKindData()",
      `Validation error: Input must be a string.`,
      {
        context,
        data: {
          data
        }
      }
    );
  }
  if (!Hex.isValid(data)) {
    throw new import_sdk_errors25.InvalidRLP(
      "assertValidHexBlobKindData()",
      `Validation error: Input must be a valid hex string with a '0x' prefix.`,
      {
        context,
        data: {
          data
        }
      }
    );
  }
  if (data.length % 2 !== 0) {
    throw new import_sdk_errors25.InvalidRLP(
      "assertValidHexBlobKindData()",
      `Validation error: Hex string must have an even length.`,
      {
        context,
        data: {
          data
        }
      }
    );
  }
};
var assertValidHexBlobKindBuffer = (buffer, context) => {
  if (!Buffer.isBuffer(buffer)) {
    throw new import_sdk_errors25.InvalidRLP(
      "assertFixedHexBlobKindData()",
      `Validation error: Input must be a valid buffer.`,
      {
        context,
        data: {
          buffer
        }
      }
    );
  }
};

// src/encoding/rlp/helpers/fixedhexblobkind.ts
var import_sdk_errors26 = require("@vechain/sdk-errors");
var assertFixedHexBlobKindData = (data, context, bytes) => {
  if (data.length !== bytes * 2 + 2) {
    throw new import_sdk_errors26.InvalidRLP(
      "assertFixedHexBlobKindData()",
      `Validation error: Hex string in ${context} must be exactly ${bytes} bytes in length.`,
      {
        context,
        data: {
          data,
          bytes
        }
      }
    );
  }
};
var assertFixedHexBlobKindBuffer = (buffer, context, bytes) => {
  if (buffer.length !== bytes) {
    throw new import_sdk_errors26.InvalidRLP(
      "assertFixedHexBlobKindData()",
      `Validation error: Hex string in ${context} must be exactly ${bytes} bytes in length.`,
      {
        context,
        data: {
          buffer,
          bytes
        }
      }
    );
  }
};

// src/encoding/rlp/helpers/compactfixedhexblobkind.ts
var import_sdk_errors27 = require("@vechain/sdk-errors");
var assertCompactFixedHexBlobBuffer = (buffer, context, bytes) => {
  if (buffer.length > bytes) {
    throw new import_sdk_errors27.InvalidRLP(
      "assertCompactFixedHexBlobBuffer()",
      `Validation error: Buffer in ${context} must be at most ${bytes} bytes.`,
      {
        context,
        data: {
          buffer,
          bytes
        }
      }
    );
  }
  if (buffer.length !== 0 && buffer[0] === 0) {
    throw new import_sdk_errors27.InvalidRLP(
      "assertCompactFixedHexBlobBuffer()",
      `Validation error: Buffer in ${context} should not have leading zero bytes.`,
      {
        context,
        data: {
          buffer,
          bytes
        }
      }
    );
  }
};
var encodeCompactFixedHexBlob = (buffer) => {
  const zeroIndex = buffer.findIndex((byte) => byte !== 0);
  return zeroIndex !== -1 ? buffer.subarray(zeroIndex) : Buffer.alloc(0);
};
var decodeBufferToHexWithLeadingZeros = (buffer, bytes) => {
  return Hex.of(buffer).fit(bytes * 2).toString();
};

// src/encoding/rlp/kind/numerickind.ts
var NumericKind = class extends ScalarKind {
  /**
   * Constructs a new instance of NumericKind.
   *
   * @param maxBytes - Optional parameter that specifies the maximum number of bytes that numeric data can occupy when encoded.
   */
  constructor(maxBytes) {
    super();
    this.maxBytes = maxBytes;
  }
  /**
   * Encodes the input data into numeric format and ensures it doesn't exceed the maximum bytes, if specified.
   *
   * @param data - The data to encode, expected to be numeric.
   * @param context - Descriptive context for error messages
   * @returns DataOutput object with an encode function.
   * @throws Will throw an error if data validation fails or encoding issues occur.
   */
  data(data, context) {
    const dataBI = validateNumericKindData(data, context);
    return {
      encode: () => encodeBigIntToBuffer(dataBI, this.maxBytes, context)
      // Encodes BigInt to Buffer, respecting maxBytes.
    };
  }
  /**
   * Decodes the input buffer into a number or hexadecimal string, ensuring it meets numeric data constraints.
   *
   * @param buffer - The buffer to decode, containing numeric data.
   * @param context - Descriptive context for error messages.
   * @returns BufferOutput object with a decode function.
   * @throws Will throw an error if buffer validation fails.
   */
  buffer(buffer, context) {
    assertValidNumericKindBuffer(buffer, context, this.maxBytes);
    return {
      decode: () => decodeBufferToNumberOrHex(buffer)
      // Decodes buffer to either a number or a hexadecimal string.
    };
  }
};

// src/encoding/rlp/kind/hexblobkinds/hexblob.ts
var HexBlobKind = class extends ScalarKind {
  /**
   * Encodes the input data into a Buffer.
   *
   * @param data - The data to encode, expected to be a '0x' prefixed even sized hex string.
   * @param context - Context string for error handling.
   * @returns An object containing an encode function which returns the encoded Buffer.
   */
  data(data, context) {
    assertValidHexBlobKindData(data, context);
    return {
      encode: () => Buffer.from(data.slice(2), "hex")
    };
  }
  /**
   * Decodes the input buffer into a hex string.
   *
   * @param buffer - The buffer to decode.
   * @param context - Context string for error handling.
   * @returns An object containing a decode function which returns the decoded hex string.
   */
  buffer(buffer, context) {
    assertValidHexBlobKindBuffer(buffer, context);
    return {
      decode: () => Hex.of(buffer).toString()
    };
  }
};

// src/encoding/rlp/kind/hexblobkinds/fixedhexblob.ts
var FixedHexBlobKind = class extends HexBlobKind {
  /**
   * Creates a new instance of the {@link FixedHexBlobKind} class.
   * @param bytes - The number of bytes the blob must have.
   */
  constructor(bytes) {
    super();
    this.bytes = bytes;
  }
  /**
   * Encodes the input data into a Buffer with validation against fixed size.
   *
   * @param data - The data to encode, expected to be a '0x' prefixed even sized hex string.
   * @param context - Context string for error handling.
   * @returns An object containing an encode function which returns the encoded Buffer.
   */
  data(data, context) {
    const encoder = super.data(data, context);
    assertFixedHexBlobKindData(data, context, this.bytes);
    return encoder;
  }
  /**
   * Decodes the input buffer into a hex string with validation against fixed size.
   *
   * @param buffer - The buffer to decode.
   * @param context - Context string for error handling.
   * @returns An object containing a decode function which returns the decoded hex string.
   */
  buffer(buffer, context) {
    const decoder = super.buffer(buffer, context);
    assertFixedHexBlobKindBuffer(buffer, context, this.bytes);
    return decoder;
  }
};

// src/encoding/rlp/kind/hexblobkinds/optionalfixedhexblob.ts
var OptionalFixedHexBlobKind = class extends FixedHexBlobKind {
  /**
   * Encodes the input data (which can be null or undefined) into a Buffer.
   *
   * @param data - The data to encode, can be null or undefined.
   * @param context - Context string for error handling.
   * @returns An object containing an encode function which returns the encoded Buffer.
   */
  data(data, context) {
    return data == null ? {
      encode: () => Buffer.alloc(0)
    } : super.data(data, context);
  }
  /**
   * Decodes the input buffer into a hex string or null if the buffer is empty.
   *
   * @param buffer - The buffer to decode, can be empty.
   * @param context - Context string for error handling.
   * @returns An object containing a decode function which returns the decoded hex string or null.
   */
  buffer(buffer, context) {
    return buffer.length === 0 ? {
      decode: () => null
    } : super.buffer(buffer, context);
  }
};

// src/encoding/rlp/kind/hexblobkinds/compactfixedhexblob.ts
var CompactFixedHexBlobKind = class extends FixedHexBlobKind {
  /**
   * Encodes the input data into a Buffer, trimming leading zeros.
   *
   * @param data - The data to encode, expected to be a '0x' prefixed hex string.
   * @param context - Context string for error handling.
   * @returns An object containing an encode function which returns the encoded Buffer.
   */
  data(data, context) {
    const buffer = super.data(data, context).encode();
    return {
      encode: () => encodeCompactFixedHexBlob(buffer)
      // Encode the buffer, trimming leading zeros.
    };
  }
  /**
   * Decodes the input buffer into a number or hexadecimal string, ensuring it meets the fixed size by padding with zeros.
   *
   * @param buffer - The buffer to decode, containing numeric data.
   * @param context - Descriptive context for error messages, usually representing the caller's identity.
   * @returns BufferOutput object with a decode function.
   * @throws Will throw an error if buffer validation fails.
   */
  buffer(buffer, context) {
    assertCompactFixedHexBlobBuffer(buffer, context, this.bytes);
    return {
      decode: () => (
        // Decode the buffer, returning a hex string with leading zeros.
        Hex.of(buffer).fit(this.bytes * 2).toString()
      )
    };
  }
};

// src/encoding/rlp/kind/index.ts
var RLPProfiles = {
  ScalarKind,
  BufferKind,
  NumericKind,
  HexBlobKind,
  FixedHexBlobKind,
  OptionalFixedHexBlobKind,
  CompactFixedHexBlobKind
};

// src/encoding/rlp/index.ts
var RLP_CODER = {
  ...RLPBase,
  ...RLPProfiles
};

// src/utils/const/transaction.ts
var TRANSACTIONS_GAS_CONSTANTS = {
  /**
   * Default gas for a transaction
   * @internal
   */
  TX_GAS: 5e3,
  /**
   * Default gas for a clause
   * @internal
   */
  CLAUSE_GAS: 16e3,
  /**
   * Default gas for a contract creation clause
   * @internal
   */
  CLAUSE_GAS_CONTRACT_CREATION: 48e3,
  /**
   * Zero gas data
   * @internal
   */
  ZERO_GAS_DATA: 4,
  /**
   * Non-zero gas data
   * @internal
   */
  NON_ZERO_GAS_DATA: 68
};
var TRANSACTION_FIELDS = [
  /**
   * Chain tag. It represents the id of the chain the transaction is sent to.
   */
  { name: "chainTag", kind: new RLP_CODER.NumericKind(1) },
  /**
   * Block reference. It represents the last block of the chain the transaction is sent to.
   */
  {
    name: "blockRef",
    kind: new RLP_CODER.CompactFixedHexBlobKind(8)
  },
  /**
   * Expiration. It represents the expiration date of the transaction.
   */
  { name: "expiration", kind: new RLP_CODER.NumericKind(4) },
  /**
   * Clauses of the transaction. They represent the actions to be executed by the transaction.
   */
  {
    name: "clauses",
    kind: {
      item: [
        {
          name: "to",
          kind: new RLP_CODER.OptionalFixedHexBlobKind(20)
        },
        { name: "value", kind: new RLP_CODER.NumericKind(32) },
        { name: "data", kind: new RLP_CODER.HexBlobKind() }
      ]
    }
  },
  /**
   * Gas price coef. It represents the gas price coefficient of the transaction.
   */
  { name: "gasPriceCoef", kind: new RLP_CODER.NumericKind(1) },
  /**
   * Gas. It represents the gas limit of the transaction.
   */
  { name: "gas", kind: new RLP_CODER.NumericKind(8) },
  /**
   * Depends on. It represents the hash of the transaction the current transaction depends on.
   */
  { name: "dependsOn", kind: new RLP_CODER.OptionalFixedHexBlobKind(32) },
  /**
   * Nonce. It represents the nonce of the transaction.
   */
  { name: "nonce", kind: new RLP_CODER.NumericKind(8) },
  /**
   * Reserved. It represents the reserved field of the transaction.
   */
  { name: "reserved", kind: { item: new RLP_CODER.BufferKind() } }
];
var TRANSACTION_FEATURES_KIND = {
  name: "reserved.features",
  kind: new RLP_CODER.NumericKind(4)
};
var TRANSACTION_SIGNATURE_KIND = {
  name: "signature",
  kind: new RLP_CODER.BufferKind()
};
var UNSIGNED_TRANSACTION_RLP = new RLP_CODER.Profiler({
  name: "tx",
  kind: TRANSACTION_FIELDS
});
var SIGNED_TRANSACTION_RLP = new RLP_CODER.Profiler({
  name: "tx",
  // Add signature to the transaction fields
  kind: TRANSACTION_FIELDS.concat([TRANSACTION_SIGNATURE_KIND])
});
var SIGNATURE_LENGTH = 65;
var BLOCK_REF_LENGTH = 8;

// src/utils/data/data.ts
var nc_utils5 = __toESM(require("@noble/curves/abstract/utils"));
var import_sdk_errors28 = require("@vechain/sdk-errors");
var decodeBytes32String = (hex) => {
  if (!Hex.isValid(hex) || Hex.of(hex).digits.length !== 64)
    throw new import_sdk_errors28.InvalidDataType(
      "dataUtils.decodeBytes32String()",
      `Failed to decode value ${hex} to string. Value is not a valid hex string or it is not 64 characters long`,
      { value: hex }
    );
  const valueInBytes = Hex.of(hex).bytes;
  const firstZeroIndex = valueInBytes.findIndex((byte) => byte === 0);
  if (firstZeroIndex === 0) {
    const firstNotZeroIndex = valueInBytes.findIndex((byte) => byte !== 0);
    return Txt.of(valueInBytes.subarray(firstNotZeroIndex)).toString();
  } else if (firstZeroIndex !== -1) {
    return Txt.of(valueInBytes.subarray(0, firstZeroIndex)).toString();
  } else {
    return Txt.of(valueInBytes).toString();
  }
};
var encodeBytes32String = (value, zeroPadding = "right") => {
  try {
    const valueInBytes = Txt.of(value).bytes;
    if (valueInBytes.length > 32) {
      throw new import_sdk_errors28.InvalidDataType(
        "dataUtils.encodeBytes32String()",
        `Failed to encode value ${value} to bytes32 string. Value exceeds 32 bytes.`,
        { value }
      );
    }
    const pad = ZERO_BYTES(32 - valueInBytes.length);
    return zeroPadding === "left" ? Hex.of(nc_utils5.concatBytes(pad, valueInBytes)).toString() : Hex.of(nc_utils5.concatBytes(valueInBytes, pad)).toString();
  } catch (e) {
    throw new import_sdk_errors28.InvalidDataType(
      "dataUtils.encodeBytes32String()",
      `Failed to encode value ${value} to bytes32 string.`,
      { value },
      e
    );
  }
};
var dataUtils = {
  decodeBytes32String,
  encodeBytes32String
};

// src/utils/transaction/transaction.ts
var import_sdk_errors29 = require("@vechain/sdk-errors");
function intrinsicGas(clauses) {
  if (clauses.length === 0) {
    return TRANSACTIONS_GAS_CONSTANTS.TX_GAS + TRANSACTIONS_GAS_CONSTANTS.CLAUSE_GAS;
  }
  return clauses.reduce((sum, clause) => {
    if (clause.to !== null) {
      if (!Address.isValid(clause.to) && !clause.to.includes("."))
        throw new import_sdk_errors29.InvalidDataType(
          "TransactionUtils.intrinsicGas()",
          `Invalid data type in clause. Each 'to' field must be a valid address.`,
          { clause }
        );
      sum += TRANSACTIONS_GAS_CONSTANTS.CLAUSE_GAS;
    } else {
      sum += TRANSACTIONS_GAS_CONSTANTS.CLAUSE_GAS_CONTRACT_CREATION;
    }
    sum += _calculateDataUsedGas(clause.data);
    return sum;
  }, TRANSACTIONS_GAS_CONSTANTS.TX_GAS);
}
function _calculateDataUsedGas(data) {
  if (data !== "" && !Hex.isValid(data))
    throw new import_sdk_errors29.InvalidDataType(
      "_calculateDataUsedGas()",
      `Invalid data type for gas calculation. Data should be a hexadecimal string.`,
      { data }
    );
  let sum = 0;
  for (let i = 2; i < data.length; i += 2) {
    if (data.substring(i, i + 2) === "00") {
      sum += TRANSACTIONS_GAS_CONSTANTS.ZERO_GAS_DATA;
    } else {
      sum += TRANSACTIONS_GAS_CONSTANTS.NON_ZERO_GAS_DATA;
    }
  }
  return sum;
}
var TransactionUtils = { intrinsicGas };

// src/utils/units/units.ts
var import_bignumber = require("bignumber.js");
var import_sdk_errors30 = require("@vechain/sdk-errors");
var BIG_NUMBER_PRECISION = 80;
var VET_DECIMAL_EXPONENT = 18;
var WEI_UNIT_NAMES = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function bigNumberOf(value) {
  let bn;
  switch (typeof value) {
    case "bigint":
      bn = (0, import_bignumber.BigNumber)(value.toString());
      break;
    case "number":
      bn = (0, import_bignumber.BigNumber)(value);
      break;
    case "string": {
      if (Hex.isValid0x(value)) {
        bn = (0, import_bignumber.BigNumber)(Hex.of(value).bi.toString());
      } else {
        bn = (0, import_bignumber.BigNumber)(value);
      }
    }
  }
  if (bn.isNaN())
    throw new import_sdk_errors30.InvalidDataType("unitUtils.bigNumberOf()", "Not a number.", {
      value: value.toString()
    });
  return bn;
}
function digitsOfFractionalPart(value) {
  let d = 0;
  const i = value.abs().integerValue(import_bignumber.BigNumber.ROUND_FLOOR);
  let f = value.abs().minus(i);
  while (!f.isInteger()) {
    ++d;
    f = f.times(10);
  }
  return d;
}
function digitsOfIntegerPart(value) {
  let d = 0;
  let i = value.abs().integerValue(import_bignumber.BigNumber.ROUND_FLOOR);
  while (i.gte(1)) {
    d++;
    i = i.div(10);
  }
  return d;
}
function digitsOfUnit(digitsOrUnit) {
  let digits;
  switch (typeof digitsOrUnit) {
    case "bigint":
      digits = Number(digitsOrUnit);
      break;
    case "number":
      digits = Math.floor(digitsOrUnit);
      break;
    case "string": {
      const index = WEI_UNIT_NAMES.indexOf(digitsOrUnit);
      if (index < 0) {
        throw new import_sdk_errors30.InvalidDataType(
          "unitUtils.digitOfUnit()",
          "Invalid unit name. Valid unit names are 'wei','kwei', 'mwei', 'gwei', 'szabo', 'finney', 'ether'",
          {
            digitsOrUnit
          }
        );
      }
      digits = index * 3;
    }
  }
  if (digits > BIG_NUMBER_PRECISION)
    throw new import_sdk_errors30.InvalidDataType(
      "unitsUtils.digitOfUnit()",
      "Precision overflow (digits or unit name).",
      { digitsOrUnit: digitsOrUnit.toString() }
    );
  if (digits < 0)
    throw new import_sdk_errors30.InvalidDataType(
      "unitsUtils.digitOfUnit()",
      "Negative precision (digits or unit name).",
      { digitsOrUnit: digitsOrUnit.toString() }
    );
  return digits;
}
function formatUnits(value, decimalsOrUnit = VET_DECIMAL_EXPONENT) {
  const bnConfig = import_bignumber.BigNumber.config();
  import_bignumber.BigNumber.set({
    DECIMAL_PLACES: BIG_NUMBER_PRECISION,
    ROUNDING_MODE: import_bignumber.BigNumber.ROUND_HALF_UP
  });
  try {
    const bn = bigNumberOf(value);
    const powerOfTen = digitsOfUnit(decimalsOrUnit);
    const divisor = (0, import_bignumber.BigNumber)(10).pow(powerOfTen);
    const result = bn.div(divisor);
    let fixedDecimals = digitsOfFractionalPart(result);
    if (fixedDecimals === 0 && decimalsOrUnit !== WEI_UNIT_NAMES[0]) {
      fixedDecimals = 1;
    }
    return result.toFixed(fixedDecimals);
  } catch (e) {
    throw new import_sdk_errors30.InvalidDataType(
      "unitsUtils.formatUnits()",
      `Unable to format units: ${e.message}`,
      { value, digitsOrUnit: decimalsOrUnit },
      e
    );
  } finally {
    import_bignumber.BigNumber.set(bnConfig);
  }
}
var formatVET = (value) => {
  return formatUnits(value, VET_DECIMAL_EXPONENT);
};
function parseUnits(value, digitsOrUnit = VET_DECIMAL_EXPONENT) {
  const bnConfig = import_bignumber.BigNumber.config();
  import_bignumber.BigNumber.set({
    DECIMAL_PLACES: BIG_NUMBER_PRECISION,
    ROUNDING_MODE: import_bignumber.BigNumber.ROUND_HALF_UP
  });
  try {
    const bn = bigNumberOf(value);
    const powerOfTen = digitsOfUnit(digitsOrUnit);
    const multiplier = (0, import_bignumber.BigNumber)(10).pow(powerOfTen);
    const result = bn.times(multiplier);
    const fractionDigits = digitsOfFractionalPart(result);
    const integerDigits = digitsOfIntegerPart(result);
    return BigInt(result.toPrecision(fractionDigits + integerDigits));
  } catch (e) {
    throw new import_sdk_errors30.InvalidDataType(
      "unitsUtils.parseUnits()",
      `Unable to format units: ${e.message}`,
      { value, decimalsOrUnit: digitsOrUnit },
      e
    );
  } finally {
    import_bignumber.BigNumber.set(bnConfig);
  }
}
var parseVET = (value) => {
  return parseUnits(value, VET_DECIMAL_EXPONENT);
};
var unitsUtils = {
  formatUnits,
  formatVET,
  parseUnits,
  parseVET
};

// src/clause/clause.ts
var import_sdk_errors31 = require("@vechain/sdk-errors");
function deployContract(contractBytecode, deployParams, clauseOptions) {
  let encodedParams = "";
  if (deployParams != null) {
    encodedParams = abi.encodeParams(deployParams.types, deployParams.values).replace("0x", "");
  }
  const transactionClause = {
    to: null,
    value: 0,
    data: contractBytecode + encodedParams
  };
  if (clauseOptions?.comment !== void 0) {
    return {
      ...transactionClause,
      comment: clauseOptions.comment
    };
  } else {
    return transactionClause;
  }
}
function functionInteraction(contractAddress, functionFragment, args, value = 0, clauseOptions) {
  const transactionClause = {
    to: contractAddress,
    value,
    data: new abi.Function(functionFragment).encodeInput(args)
  };
  if (clauseOptions !== void 0) {
    return {
      ...transactionClause,
      comment: clauseOptions.comment,
      abi: clauseOptions.includeABI === true ? functionFragment.format("json") : void 0
    };
  } else {
    return transactionClause;
  }
}
function transferToken(tokenAddress, recipientAddress, amount, clauseOptions) {
  try {
    return functionInteraction(
      tokenAddress,
      coder.createInterface(VIP180_ABI).getFunction("transfer"),
      [recipientAddress, BigInt(amount)],
      void 0,
      clauseOptions
    );
  } catch (error) {
    throw new import_sdk_errors31.InvalidDataType(
      "transferToken()",
      `Invalid 'amount' parameter. Expected an integer but received ${amount}.`,
      { amount },
      error
    );
  }
}
function transferVET(recipientAddress, amount, clauseOptions) {
  try {
    const bnAmount = BigInt(amount);
    if (bnAmount < 0) {
      throw new import_sdk_errors31.InvalidDataType(
        "transferVET()",
        `Invalid 'amount' parameter. Expected a positive amount but received ${amount}.`,
        { amount }
      );
    }
    const transactionClause = {
      to: recipientAddress,
      value: `0x${BigInt(amount).toString(16)}`,
      data: "0x"
    };
    if (clauseOptions?.comment !== void 0) {
      return {
        ...transactionClause,
        comment: clauseOptions.comment
      };
    } else {
      return transactionClause;
    }
  } catch (error) {
    throw new import_sdk_errors31.InvalidDataType(
      "transferVET()",
      `Invalid 'amount' parameter. Expected an integer but received ${amount}.`,
      { amount },
      error
    );
  }
}
function transferNFT(contractAddress, senderAddress, recipientAddress, tokenId, clauseOptions) {
  if (tokenId === "") {
    throw new import_sdk_errors31.InvalidDataType(
      "transferNFT()",
      `Invalid 'tokenId' parameter. Expected an id but received ${tokenId}.`,
      { tokenId }
    );
  }
  if (!Address.isValid(senderAddress)) {
    throw new import_sdk_errors31.InvalidDataType(
      "transferNFT()",
      `Invalid 'senderAddress' parameter. Expected a contract address but received ${senderAddress}.`,
      { senderAddress }
    );
  }
  if (!Address.isValid(contractAddress)) {
    throw new import_sdk_errors31.InvalidDataType(
      "transferNFT()",
      `Invalid 'senderAddress' parameter. Expected a contract address but received ${contractAddress}.`,
      { contractAddress }
    );
  }
  const functionFragment = coder.createInterface(ERC721_ABI).getFunction("transferFrom");
  return functionInteraction(
    contractAddress,
    functionFragment,
    [senderAddress, recipientAddress, tokenId],
    void 0,
    clauseOptions
  );
}
var clauseBuilder = {
  deployContract,
  functionInteraction,
  transferToken,
  transferVET,
  transferNFT
};

// src/keystore/keystore.ts
var import_sdk_logging = require("@vechain/sdk-logging");

// src/keystore/cryptography/ethers/keystore.ts
var import_ethers4 = require("ethers");

// src/keystore/cryptography/ethers/const/keystore.ts
var SCRYPT_PARAMS = {
  N: 131072,
  r: 8,
  p: 1
};

// src/keystore/cryptography/ethers/keystore.ts
var import_sdk_errors32 = require("@vechain/sdk-errors");
async function encrypt(privateKey, password) {
  const derivePublicKey = Secp256k1.derivePublicKey(privateKey);
  const deriveAddress = Address.ofPublicKey(
    Buffer.from(derivePublicKey)
  ).toString();
  const keystoreAccount = {
    address: deriveAddress,
    privateKey: Hex.of(privateKey).toString()
  };
  const encryptOptions = {
    scrypt: {
      N: SCRYPT_PARAMS.N,
      r: SCRYPT_PARAMS.r,
      p: SCRYPT_PARAMS.p
    }
  };
  const keystoreJsonString = await import_ethers4.ethers.encryptKeystoreJson(
    keystoreAccount,
    password,
    encryptOptions
  );
  return JSON.parse(keystoreJsonString);
}
async function decrypt(keystore4, password) {
  if (!isValid(keystore4)) {
    throw new import_sdk_errors32.InvalidKeystore(
      "keystore.decrypt()",
      "Invalid keystore. Ensure the keystore is properly formatted and contains the necessary data.",
      { keystore: keystore4 }
    );
  }
  try {
    return await import_ethers4.ethers.decryptKeystoreJson(
      (0, import_sdk_errors32.stringifyData)(keystore4),
      password
    );
  } catch (e) {
    throw new import_sdk_errors32.InvalidKeystoreParams(
      "keystore.decrypt()",
      "Decryption failed: Invalid Password for the given keystore.",
      // @NOTE: We are not exposing the password in the error data for security reasons.
      {
        keystore: keystore4
      }
    );
  }
}
function isValid(keystore4) {
  return import_ethers4.ethers.isKeystoreJson((0, import_sdk_errors32.stringifyData)(keystore4));
}
var keystore = { encrypt, decrypt, isValid };

// src/keystore/cryptography/experimental/keystore.ts
var n_utils = __toESM(require("@noble/curves/abstract/utils"));
var import_sdk_errors33 = require("@vechain/sdk-errors");
var import_aes = require("@noble/ciphers/aes");
var import_scrypt = require("@noble/hashes/scrypt");
var KEYSTORE_CRYPTO_CIPHER = "aes-128-ctr";
var KEYSTORE_CRYPTO_PARAMS_DKLEN = 32;
var KEYSTORE_CRYPTO_KDF = "scrypt";
var KEYSTORE_VERSION = 3;
var SCRYPT_PARAMS2 = {
  N: 131072,
  r: 8,
  p: 1
};
function decodeScryptParams(keystore4) {
  const salt = n_utils.hexToBytes(keystore4.crypto.kdfparams.salt);
  const N = keystore4.crypto.kdfparams.n;
  const r = keystore4.crypto.kdfparams.r;
  const p = keystore4.crypto.kdfparams.p;
  if (N <= 0 || (N & N - 1) !== 0)
    throw new import_sdk_errors33.InvalidKeystoreParams(
      "(EXPERIMENTAL) keystore.decodeScryptParams()",
      "Decryption failed: invalid  keystore.crypto.kdfparams.n parameter.",
      {
        keystore: keystore4,
        N
      }
    );
  if (r <= 0 || p <= 0)
    throw new import_sdk_errors33.InvalidKeystoreParams(
      "(EXPERIMENTAL) keystore.decodeScryptParams()",
      "Decryption failed: both keystore.crypto.kdfparams.r or keystore.crypto.kdfparams.p parameter must be > 0.",
      {
        keystore: keystore4,
        r,
        p
      }
    );
  const dkLen = keystore4.crypto.kdfparams.dklen;
  if (dkLen !== KEYSTORE_CRYPTO_PARAMS_DKLEN)
    throw new import_sdk_errors33.InvalidKeystoreParams(
      "(EXPERIMENTAL) keystore.decodeScryptParams()",
      `Decryption failed: keystore.crypto.kdfparams.dklen parameter must be ${KEYSTORE_CRYPTO_PARAMS_DKLEN}`,
      {
        keystore: keystore4,
        dkLen
      }
    );
  return {
    N,
    dkLen: KEYSTORE_CRYPTO_PARAMS_DKLEN,
    name: KEYSTORE_CRYPTO_KDF,
    p,
    r,
    salt
  };
}
function encodeScryptParams(options) {
  const salt = options.salt ?? Secp256k1.randomBytes(KEYSTORE_CRYPTO_PARAMS_DKLEN);
  let N = SCRYPT_PARAMS2.N;
  let r = SCRYPT_PARAMS2.r;
  let p = SCRYPT_PARAMS2.p;
  if (options.scrypt != null) {
    if (options.scrypt.N != null) {
      N = options.scrypt.N;
    }
    if (options.scrypt.r != null) {
      r = options.scrypt.r;
    }
    if (options.scrypt.p != null) {
      p = options.scrypt.p;
    }
  }
  if (N <= 0 || (BigInt(N) & BigInt(N - 1)) !== BigInt(0))
    throw new import_sdk_errors33.InvalidKeystoreParams(
      "(EXPERIMENTAL) keystore.encodeScryptParams()",
      "Encryption failed: invalid options.scrypt.N parameter.",
      {
        options,
        N
      }
    );
  if (r <= 0 || !Number.isSafeInteger(r))
    throw new import_sdk_errors33.InvalidKeystoreParams(
      "(EXPERIMENTAL) keystore.encodeScryptParams()",
      "Encryption failed: invalid options.scrypt.r parameter.",
      {
        options,
        r
      }
    );
  if (p <= 0 || !Number.isSafeInteger(p))
    throw new import_sdk_errors33.InvalidKeystoreParams(
      "(EXPERIMENTAL) keystore.encodeScryptParams()",
      "Encryption failed: invalid options.scrypt.p parameter.",
      {
        options,
        p
      }
    );
  return {
    name: KEYSTORE_CRYPTO_KDF,
    dkLen: KEYSTORE_CRYPTO_PARAMS_DKLEN,
    N,
    p,
    r,
    salt
  };
}
function encrypt2(privateKey, password) {
  return encryptKeystore(privateKey, password, {
    scrypt: {
      N: SCRYPT_PARAMS2.N,
      r: SCRYPT_PARAMS2.r,
      p: SCRYPT_PARAMS2.p
    }
  });
}
function encryptKeystore(privateKey, password, options) {
  try {
    const kdf = encodeScryptParams(options);
    const key = (0, import_scrypt.scrypt)(password, kdf.salt, {
      N: kdf.N,
      r: kdf.r,
      p: kdf.p,
      dkLen: kdf.dkLen
    });
    const iv = options.iv ?? Secp256k1.randomBytes(16);
    if (iv.length !== 16)
      throw new import_sdk_errors33.InvalidKeystoreParams(
        "(EXPERIMENTAL) keystore.encryptKeystore()",
        "Encryption failed: invalid options.iv length.",
        { iv }
      );
    const uuidRandom = options.uuid ?? Secp256k1.randomBytes(16);
    if (uuidRandom.length !== 16)
      throw new import_sdk_errors33.InvalidKeystoreParams(
        "(EXPERIMENTAL) keystore.encryptKeystore()",
        "Encryption failed: invalid options.uuid length.",
        { uuidRandom }
      );
    const macPrefix = key.slice(16, 32);
    const ciphertext = (0, import_aes.ctr)(key.slice(0, 16), iv).encrypt(privateKey);
    return {
      address: Address.ofPrivateKey(privateKey).toString(),
      crypto: {
        cipher: KEYSTORE_CRYPTO_CIPHER,
        cipherparams: {
          iv: Hex.of(iv).digits
        },
        ciphertext: Hex.of(ciphertext).digits,
        kdf: "scrypt",
        kdfparams: {
          dklen: KEYSTORE_CRYPTO_PARAMS_DKLEN,
          n: kdf.N,
          p: kdf.p,
          r: kdf.r,
          salt: Hex.of(kdf.salt).digits
        },
        // Compute the message authentication code, used to check the password.
        mac: Keccak256.of(n_utils.concatBytes(macPrefix, ciphertext)).digits
      },
      id: uuidV4(uuidRandom),
      version: KEYSTORE_VERSION
    };
  } finally {
    privateKey.fill(0);
    password.fill(0);
  }
}
function decrypt2(keystore4, password) {
  return decryptKeystore(keystore4, password);
}
function decryptKeystore(keystore4, password) {
  try {
    if (keystore4.crypto.cipher.toLowerCase() !== KEYSTORE_CRYPTO_CIPHER)
      throw new import_sdk_errors33.InvalidKeystoreParams(
        "(EXPERIMENTAL) keystore.decryptKeystore()",
        "Decryption failed: unsupported crypto cipher algorithm.",
        { cipher: keystore4.crypto.cipher.toLowerCase() }
      );
    if (keystore4.crypto.kdf.toLowerCase() !== KEYSTORE_CRYPTO_KDF)
      throw new import_sdk_errors33.InvalidKeystoreParams(
        "(EXPERIMENTAL) keystore.decryptKeystore()",
        "Decryption failed: unsupported crypto key derivation function.",
        { keyDerivationFunction: keystore4.crypto.kdf.toLowerCase() }
      );
    if (keystore4.version !== KEYSTORE_VERSION)
      throw new import_sdk_errors33.InvalidKeystoreParams(
        "(EXPERIMENTAL) keystore.decryptKeystore()",
        "Decryption failed: unsupported keystore version.",
        { version: keystore4.version }
      );
    const kdf = decodeScryptParams(keystore4);
    const key = (0, import_scrypt.scrypt)(password, kdf.salt, {
      N: kdf.N,
      r: kdf.r,
      p: kdf.p,
      dkLen: kdf.dkLen
    });
    const ciphertext = n_utils.hexToBytes(keystore4.crypto.ciphertext);
    if (keystore4.crypto.mac !== Keccak256.of(n_utils.concatBytes(key.slice(16, 32), ciphertext)).digits) {
      throw new import_sdk_errors33.InvalidKeystoreParams(
        "(EXPERIMENTAL) keystore.decryptKeystore()",
        "Decryption failed: Invalid Password for the given keystore.",
        // @NOTE: We are not exposing the password in the error data for security reasons.
        {
          keystore: keystore4
        }
      );
    }
    const privateKey = (0, import_aes.ctr)(
      key.slice(0, 16),
      n_utils.hexToBytes(keystore4.crypto.cipherparams.iv)
    ).decrypt(ciphertext);
    const address = Address.ofPrivateKey(privateKey).toString();
    if (keystore4.address !== "" && address !== Address.checksum(Hex.of(keystore4.address))) {
      throw new import_sdk_errors33.InvalidKeystoreParams(
        "(EXPERIMENTAL) keystore.decryptKeystore()",
        "Decryption failed: address/password mismatch.",
        { keystoreAddress: keystore4.address }
      );
    }
    return {
      address,
      // @note: Convert the private key to a string to be compatible with ethers
      privateKey: Hex.of(privateKey).toString()
    };
  } finally {
    password.fill(0);
  }
}
function isValid2(keystore4) {
  try {
    const copy = JSON.parse((0, import_sdk_errors33.stringifyData)(keystore4));
    if (copy.crypto.cipher.toLowerCase() === KEYSTORE_CRYPTO_CIPHER && copy.crypto.kdf.toLowerCase() === KEYSTORE_CRYPTO_KDF && copy.version === KEYSTORE_VERSION) {
      return true;
    }
  } catch (error) {
  }
  return false;
}
function uuidV4(bytes) {
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const value = Hex.of(bytes).digits;
  return [
    value.substring(0, 8),
    value.substring(8, 12),
    value.substring(12, 16),
    value.substring(16, 20),
    value.substring(20, 32)
  ].join("-");
}
var keystore2 = { decrypt: decrypt2, encrypt: encrypt2, isValid: isValid2 };

// src/keystore/keystore.ts
var EXPERIMENTAL_CRYPTOGRAPHY = false;
function useExperimentalCryptography(experimentalCryptography) {
  EXPERIMENTAL_CRYPTOGRAPHY = experimentalCryptography;
}
async function encrypt3(privateKey, password) {
  if (EXPERIMENTAL_CRYPTOGRAPHY)
    (0, import_sdk_logging.VeChainSDKLogger)("warning").log({
      title: `Experimental cryptography`,
      messages: [
        `Remember, you are using an experimental cryptography library.`,
        "functions: keystore.encrypt"
      ]
    });
  return EXPERIMENTAL_CRYPTOGRAPHY ? keystore2.encrypt(privateKey, Txt.of(password).bytes) : await keystore.encrypt(privateKey, password);
}
async function decrypt3(keystore4, password) {
  if (EXPERIMENTAL_CRYPTOGRAPHY)
    (0, import_sdk_logging.VeChainSDKLogger)("warning").log({
      title: `Experimental cryptography`,
      messages: [
        `Remember, you are using an experimental cryptography library.`,
        "functions: keystore.decrypt"
      ]
    });
  return EXPERIMENTAL_CRYPTOGRAPHY ? keystore2.decrypt(keystore4, Txt.of(password).bytes) : await keystore.decrypt(keystore4, password);
}
function isValid3(keystore4) {
  if (EXPERIMENTAL_CRYPTOGRAPHY)
    (0, import_sdk_logging.VeChainSDKLogger)("warning").log({
      title: `Experimental cryptography`,
      messages: [
        `Remember, you are using an experimental cryptography library.`,
        "functions: keystore.isValid"
      ]
    });
  return EXPERIMENTAL_CRYPTOGRAPHY ? keystore2.isValid(keystore4) : keystore.isValid(keystore4);
}
var keystore3 = { encrypt: encrypt3, decrypt: decrypt3, isValid: isValid3, useExperimentalCryptography };

// src/transaction/transaction.ts
var import_sdk_errors34 = require("@vechain/sdk-errors");
var Transaction = class _Transaction {
  /**
   * Transaction body. It represents the body of the transaction.
   *
   * @note It is better to take it as a read-only property in order to avoid any external modification.
   */
  body;
  /**
   * Transaction signature. It represents the signature of the transaction.
   *
   * @note It is better to take it as a read-only property in order to avoid any external modification.
   */
  signature;
  /**
   * Constructor with parameters.
   * This constructor creates a transaction immutable object.
   *
   * @param body - Transaction body
   * @param signature - Optional signature for the transaction
   * @throws {InvalidTransactionField, InvalidSecp256k1Signature}
   */
  constructor(body, signature) {
    if (!_Transaction.isValidBody(body)) {
      throw new import_sdk_errors34.InvalidTransactionField(
        "Transaction constructor",
        "Invalid transaction body. Ensure all required fields are correctly formatted and present.",
        { fieldName: "body", body }
      );
    }
    this.body = body;
    if (signature !== void 0 && !this._isSignatureValid(signature)) {
      throw new import_sdk_errors34.InvalidSecp256k1Signature(
        "Transaction constructor",
        "Invalid transaction signature. Ensure it is correctly formatted.",
        { signature }
      );
    }
    this.signature = signature;
  }
  // ********** PUBLIC GET ONLY FUNCTIONS **********
  /**
   * Calculate intrinsic gas required for this transaction
   *
   * @returns Intrinsic gas required for this transaction
   */
  get intrinsicGas() {
    return TransactionUtils.intrinsicGas(this.body.clauses);
  }
  /**
   * Determines whether the transaction is delegated.
   *
   * @returns If transaction is delegated or not
   */
  get isDelegated() {
    return this._isDelegated(this.body);
  }
  /**
   * Get transaction delegator address from signature.
   *
   * @returns Transaction delegator address
   * @throws {NotDelegatedTransaction, UnavailableTransactionField}
   */
  get delegator() {
    if (!this.isDelegated)
      throw new import_sdk_errors34.NotDelegatedTransaction(
        "Transaction.delegator()",
        "Transaction is not delegated. Delegate information is unavailable.",
        void 0
      );
    if (!this.isSigned)
      throw new import_sdk_errors34.UnavailableTransactionField(
        "Transaction.delegator()",
        "Transaction is not signed. 'delegator' information is unavailable.",
        { fieldName: "delegator" }
      );
    const signatureSliced = this.signature.subarray(
      65,
      this.signature?.length
    );
    const delegatorPublicKey = Secp256k1.recover(
      this.getSignatureHash(this.origin),
      signatureSliced
    );
    return Address.ofPublicKey(Buffer.from(delegatorPublicKey)).toString();
  }
  /**
   * Determines whether the transaction is signed or not.
   *
   * @returns If transaction is signed or not
   */
  get isSigned() {
    return this.signature !== void 0;
  }
  /**
   * Computes the signature hash for the transaction. The output is based on
   * the presence of the 'delegateFor' parameter.
   *
   * @param delegateFor - Optional address of the delegator.
   * @returns The computed hash.
   *
   * Mainly:
   *  - No 'delegateFor': return txHash
   * - 'delegateFor' return txHash +  hash('delegateFor' address)
   *
   * @remarks
   * delegateFor is used to sign a transaction on behalf of another account.
   * In fact when the delegator sign the transaction, delegator will add the address
   * of who send the transaction to sign (in this case the 'delegateFor' address parameter)
   *
   * @example
   * A is transaction origin
   * B is the delegator
   * TX is the transaction
   *
   * A sends a TX (signed by A) to B to who add his signature to TX using delegateFor parameter (that is A address)
   * on signing hash of TX computation.
   *
   * Mathematically:
   *
   * ```
   * final_signature = concat_buffer(
   *      sign(TX.signingHash(), A.privateKey),
   *      sign(TX.signingHash(A.address), B.privateKey)
   * )
   * ```
   *
   * Where:
   *
   * ```
   * TX.signatureHash() = blake2b256(TX.encoded)
   * TX.signingHash(A.address) = blake2b256(
   *      concat(
   *              blake2b256(TX.encoded),
   *              A.address
   *             )
   * )
   * ```
   *
   * @param delegateFor - Address of the delegator
   * @returns Signing hash of the transaction
   * @throws {InvalidTransactionField}
   */
  getSignatureHash(delegateFor) {
    if (delegateFor !== void 0 && !Address.isValid(delegateFor)) {
      throw new import_sdk_errors34.InvalidTransactionField(
        "Transaction.getSignatureHash()",
        "Invalid address given as input as delegateFor parameter. Ensure it is a valid address.",
        { fieldName: "delegateFor", delegateFor }
      );
    }
    const transactionHash = Blake2b256.of(this._encode(false)).bytes;
    if (delegateFor !== void 0) {
      return Buffer.from(
        Blake2b256.of(
          Buffer.concat([
            Buffer.from(transactionHash),
            Buffer.from(delegateFor.slice(2), "hex")
          ])
        ).bytes
      );
    }
    return Buffer.from(transactionHash);
  }
  /**
   * Encode a transaction
   *
   * @returns The transaction encoded
   */
  get encoded() {
    return this._encode(this.isSigned);
  }
  /**
   * Get transaction origin address from signature.
   *
   * @returns Transaction origin
   * @throws {UnavailableTransactionField}
   */
  get origin() {
    if (!this.isSigned)
      throw new import_sdk_errors34.UnavailableTransactionField(
        "Transaction.origin()",
        "Transaction is not signed. 'origin' information is unavailable.",
        { fieldName: "origin" }
      );
    const signatureSliced = this.signature.subarray(0, 65);
    const originPublicKey = Secp256k1.recover(
      this.getSignatureHash(),
      signatureSliced
    );
    return Address.ofPublicKey(Buffer.from(originPublicKey)).toString();
  }
  /**
   * Get transaction ID from signature.
   *
   * @returns Transaction ID
   * @throws {UnavailableTransactionField}
   */
  get id() {
    if (!this.isSigned)
      throw new import_sdk_errors34.UnavailableTransactionField(
        "Transaction.id()",
        "Transaction is not signed. 'id' information is unavailable.",
        { fieldName: "id" }
      );
    return Blake2b256.of(
      Buffer.concat([
        this.getSignatureHash(),
        Buffer.from(this.origin.slice(2), "hex")
      ])
    ).toString();
  }
  // ********** INTERNAL PRIVATE FUNCTIONS **********
  /**
   * Internal function to check if transaction is delegated or not.
   * This function is used to check directly the transaction body.
   * @private
   *
   * @param body Transaction body to check
   * @returns Weather the transaction is delegated or not
   */
  _isDelegated(body) {
    const reserved = body.reserved ?? {};
    const features = reserved.features ?? 0;
    return (features & 1) === 1;
  }
  /**
   * Internal function to check if signature is valid or not.
   * This function is used to check directly the signature.
   * @private
   *
   * @param signature Signature to check
   * @returns Weather the signature is valid or not
   */
  _isSignatureValid(signature) {
    const expectedSignatureLength = this._isDelegated(this.body) ? SIGNATURE_LENGTH * 2 : SIGNATURE_LENGTH;
    return signature.length === expectedSignatureLength;
  }
  /**
   * Encodes the reserved field to ensure it exists in every encoding.
   *
   * Due to the fact that reserved field is optional in TransactionBody,
   * BUT mandatory in RLPProfiler, we need to have it in every encoding.
   * Fot this reason this function is needed.
   * @private
   *
   * @returns Encoding of reserved field
   */
  _encodeReservedField() {
    const reserved = this.body.reserved ?? {};
    const featuresKind = TRANSACTION_FEATURES_KIND.kind;
    const featuresList = [
      featuresKind.data(reserved.features ?? 0, TRANSACTION_FEATURES_KIND.name).encode(),
      ...reserved.unused ?? []
    ];
    while (featuresList.length > 0) {
      if (featuresList[featuresList.length - 1].length === 0) {
        featuresList.pop();
      } else {
        break;
      }
    }
    return featuresList;
  }
  /**
   * Make the RLP encoding of a transaction body.
   * @private
   *
   * @param body Body to encode
   * @param isSigned If transaction is signed or not
   * @returns RLP encoding of transaction body
   */
  _lowLevelEncodeTransactionBodyWithRLP(body, isSigned) {
    if (isSigned) {
      return SIGNED_TRANSACTION_RLP.encodeObject({
        ...body,
        signature: this.signature
      });
    }
    return UNSIGNED_TRANSACTION_RLP.encodeObject(body);
  }
  /**
   * Private utility function to encode a transaction.
   * @private
   *
   * @param isSigned If transaction is signed or not (needed to determine if encoding with SIGNED_TRANSACTION_RLP or UNSIGNED_TRANSACTION_RLP)
   * @returns Encoding of transaction
   */
  _encode(isSigned) {
    return this._lowLevelEncodeTransactionBodyWithRLP(
      {
        // Existing body (clauses, gasPrice, gasLimit, nonce, chainTag, blockRef, expiration, ... AND OPTIONALLY reserved field)
        ...this.body,
        /*
         * @note: this.body.clauses is already an array.
         * But TypeScript doesn't know that and for this reason we need to cast it.
         * Otherwise encodeObject will throw an error.
         */
        clauses: this.body.clauses,
        // New reserved field
        reserved: this._encodeReservedField()
      },
      isSigned
    );
  }
  /**
   * utility function to check transaction body validity.
   *
   * @param body Transaction body to check
   */
  static isValidBody(body) {
    return (
      // Chain tag
      body.chainTag !== void 0 && body.chainTag >= 0 && body.chainTag <= 255 && // Block reference
      body.blockRef !== void 0 && Hex.isValid0x(body.blockRef) && Buffer.from(body.blockRef.slice(2), "hex").length === BLOCK_REF_LENGTH && // Expiration
      body.expiration !== void 0 && // Clauses
      body.clauses !== void 0 && // Gas price coef
      body.gasPriceCoef !== void 0 && // Gas
      body.gas !== void 0 && // Depends on
      body.dependsOn !== void 0 && // Nonce
      body.nonce !== void 0
    );
  }
};

// src/transaction/handlers/sign.ts
var import_sdk_errors35 = require("@vechain/sdk-errors");
function sign2(transactionBody, signerPrivateKey) {
  if (!Secp256k1.isValidPrivateKey(signerPrivateKey)) {
    throw new import_sdk_errors35.InvalidSecp256k1PrivateKey(
      `TransactionHandler.sign()`,
      "Invalid private key used to sign the transaction. Ensure it's a valid secp256k1 private key.",
      void 0
    );
  }
  const transactionToSign = new Transaction(transactionBody);
  if (transactionToSign.isDelegated)
    throw new import_sdk_errors35.InvalidTransactionField(
      `TransactionHandler.sign()`,
      "Transaction is delegated. Use signWithDelegator method instead.",
      { fieldName: "delegator", transactionBody }
    );
  const signature = Secp256k1.sign(
    transactionToSign.getSignatureHash(),
    signerPrivateKey
  );
  return new Transaction(transactionBody, Buffer.from(signature));
}
function signWithDelegator(transactionBody, signerPrivateKey, delegatorPrivateKey) {
  if (!Secp256k1.isValidPrivateKey(signerPrivateKey)) {
    throw new import_sdk_errors35.InvalidSecp256k1PrivateKey(
      `TransactionHandler.signWithDelegator()`,
      "Invalid signer private key used to sign the transaction. Ensure it's a valid secp256k1 private key.",
      void 0
    );
  }
  if (!Secp256k1.isValidPrivateKey(delegatorPrivateKey)) {
    throw new import_sdk_errors35.InvalidSecp256k1PrivateKey(
      `TransactionHandler.signWithDelegator()`,
      "Invalid delegator private key used to sign the transaction. Ensure it's a valid secp256k1 private key.",
      void 0
    );
  }
  const transactionToSign = new Transaction(transactionBody);
  if (!transactionToSign.isDelegated)
    throw new import_sdk_errors35.NotDelegatedTransaction(
      "signWithDelegator()",
      "Transaction is not delegated. Use 'sign()' method instead.",
      void 0
    );
  const transactionHash = transactionToSign.getSignatureHash();
  const delegatedHash = transactionToSign.getSignatureHash(
    Address.ofPublicKey(
      Secp256k1.derivePublicKey(signerPrivateKey)
    ).toString()
  );
  const signature = Buffer.concat([
    Secp256k1.sign(transactionHash, signerPrivateKey),
    Secp256k1.sign(delegatedHash, delegatorPrivateKey)
  ]);
  return new Transaction(transactionBody, signature);
}

// src/transaction/handlers/decode.ts
var import_sdk_errors36 = require("@vechain/sdk-errors");
function decode3(rawTransaction, isSigned) {
  const decoder = isSigned ? SIGNED_TRANSACTION_RLP : UNSIGNED_TRANSACTION_RLP;
  const decodedRLPBody = decoder.decodeObject(
    rawTransaction
  );
  const bodyWithoutReservedField = {
    blockRef: decodedRLPBody.blockRef,
    chainTag: decodedRLPBody.chainTag,
    clauses: decodedRLPBody.clauses,
    dependsOn: decodedRLPBody.dependsOn,
    expiration: decodedRLPBody.expiration,
    gas: decodedRLPBody.gas,
    gasPriceCoef: decodedRLPBody.gasPriceCoef,
    nonce: decodedRLPBody.nonce
  };
  const correctTransactionBody = decodedRLPBody.reserved.length > 0 ? {
    ...bodyWithoutReservedField,
    reserved: _decodeReservedField(
      decodedRLPBody.reserved
    )
  } : bodyWithoutReservedField;
  return decodedRLPBody.signature !== void 0 ? new Transaction(
    correctTransactionBody,
    decodedRLPBody.signature
  ) : new Transaction(correctTransactionBody);
}
function _decodeReservedField(reserved) {
  if (reserved[reserved.length - 1].length === 0) {
    throw new import_sdk_errors36.InvalidTransactionField(
      "_decodeReservedField()",
      "Invalid reserved field. Fields in the reserved buffer must be properly trimmed.",
      { fieldName: "reserved", reserved }
    );
  }
  const featuresField = TRANSACTION_FEATURES_KIND.kind.buffer(reserved[0], TRANSACTION_FEATURES_KIND.name).decode();
  return reserved.length > 1 ? {
    features: featuresField,
    unused: reserved.slice(1)
  } : { features: featuresField };
}

// src/transaction/transaction-handler.ts
var TransactionHandler = {
  // Sign transaction
  sign: sign2,
  signWithDelegator,
  // Decode transaction
  decode: decode3
};

// src/utils/const/network.ts
var VECHAIN_MAINNET_CHAIN_TAG = 74;
var VECHAIN_TESTNET_CHAIN_TAG = 39;
var VECHAIN_SOLO_CHAIN_TAG = 246;
var ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
var VTHO_ADDRESS = "0x0000000000000000000000000000456e65726779";
var mainnetGenesisBlock = {
  number: 0,
  id: "0x00000000851caf3cfdb6e899cf5958bfb1ac3413d346d43539627e6be7ec1b4a",
  size: 170,
  parentID: "0xffffffff53616c757465202620526573706563742c20457468657265756d2100",
  timestamp: 1530316800,
  gasLimit: 1e7,
  beneficiary: "0x0000000000000000000000000000000000000000",
  gasUsed: 0,
  totalScore: 0,
  txsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  txsFeatures: 0,
  stateRoot: "0x09bfdf9e24dd5cd5b63f3c1b5d58b97ff02ca0490214a021ed7d99b93867839c",
  receiptsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  signer: "0x0000000000000000000000000000000000000000",
  isTrunk: true,
  transactions: []
};
var testnetGenesisBlock = {
  number: 0,
  id: "0x000000000b2bce3c70bc649a02749e8687721b09ed2e15997f466536b20bb127",
  size: 170,
  parentID: "0xffffffff00000000000000000000000000000000000000000000000000000000",
  timestamp: 1530014400,
  gasLimit: 1e7,
  beneficiary: "0x0000000000000000000000000000000000000000",
  gasUsed: 0,
  totalScore: 0,
  txsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  txsFeatures: 0,
  stateRoot: "0x4ec3af0acbad1ae467ad569337d2fe8576fe303928d35b8cdd91de47e9ac84bb",
  receiptsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  signer: "0x0000000000000000000000000000000000000000",
  isTrunk: true,
  transactions: []
};
var soloGenesisBlock = {
  number: 0,
  id: "0x00000000c05a20fbca2bf6ae3affba6af4a74b800b585bf7a4988aba7aea69f6",
  size: 170,
  parentID: "0xffffffff00000000000000000000000000000000000000000000000000000000",
  timestamp: 15264e5,
  gasLimit: 1e7,
  beneficiary: "0x0000000000000000000000000000000000000000",
  gasUsed: 0,
  totalScore: 0,
  txsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  txsFeatures: 0,
  stateRoot: "0x93de0ffb1f33bc0af053abc2a87c4af44594f5dcb1cb879dd823686a15d68550",
  receiptsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  signer: "0x0000000000000000000000000000000000000000",
  isTrunk: true,
  transactions: []
};
var MAINNET_NETWORK = {
  genesisBlock: mainnetGenesisBlock,
  chainTag: VECHAIN_MAINNET_CHAIN_TAG
};
var TESTNET_NETWORK = {
  genesisBlock: testnetGenesisBlock,
  chainTag: VECHAIN_TESTNET_CHAIN_TAG
};
var SOLO_NETWORK = {
  genesisBlock: soloGenesisBlock,
  chainTag: VECHAIN_SOLO_CHAIN_TAG
};
var networkInfo = {
  mainnet: MAINNET_NETWORK,
  testnet: TESTNET_NETWORK,
  solo: SOLO_NETWORK
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Account,
  Address,
  BLOCK_REF_LENGTH,
  Blake2b256,
  BloomFilter,
  ERC1155_ABI,
  ERC20_ABI,
  ERC721_ABI,
  FPN,
  HDKey,
  Hex,
  HexInt,
  HexUInt,
  Keccak256,
  MAINNET_NETWORK,
  Mnemonic,
  NUMERIC_REGEX,
  Quantity,
  RLPBase,
  RLPProfiles,
  RLP_CODER,
  Revision,
  SIGNATURE_LENGTH,
  SIGNED_TRANSACTION_RLP,
  SOLO_NETWORK,
  Secp256k1,
  Sha256,
  TESTNET_NETWORK,
  TRANSACTIONS_GAS_CONSTANTS,
  TRANSACTION_FEATURES_KIND,
  TRANSACTION_SIGNATURE_KIND,
  ThorId,
  Transaction,
  TransactionHandler,
  TransactionUtils,
  Txt,
  UNSIGNED_TRANSACTION_RLP,
  VIP180_ABI,
  VIP181_ABI,
  VIP210_ABI,
  VTHO_ADDRESS,
  ZERO_ADDRESS,
  ZERO_BYTES,
  abi,
  addressUtils,
  assertCompactFixedHexBlobBuffer,
  assertFixedHexBlobKindBuffer,
  assertFixedHexBlobKindData,
  assertValidHexBlobKindBuffer,
  assertValidHexBlobKindData,
  assertValidNumericKindBuffer,
  blake2b256,
  certificate,
  clauseBuilder,
  coder,
  core,
  dataUtils,
  decodeBufferToHexWithLeadingZeros,
  decodeBufferToNumberOrHex,
  encodeBigIntToBuffer,
  encodeCompactFixedHexBlob,
  fragment,
  keccak256,
  keystore,
  mnemonic,
  networkInfo,
  revisionUtils,
  sha256,
  unitsUtils,
  validateNumericKindData,
  vechain_sdk_core_ethers
});
